<application>
  <component name="AppStorage">
    <histories>
      <item value="refinement" />
      <item value="A refinement of StreamObserver provided by the GRPC runtime to the application (the client or the server) that allows for more complex interactions with call behavior." />
      <item value="This API is asynchronous, so methods may return before the operation completes. The API provides no guarantees for how quickly an operation will complete, so utilizing flow control via ClientCallStreamObserver and ServerCallStreamObserver to avoid excessive buffering is recommended for streaming RPCs. gRPC's implementation of onError() on client-side causes the RPC to be cancelled and discards all messages, so completes quickly." />
      <item value="Receives notifications from an observable stream of messages.&#10;" />
      <item value="Internal Instrumented" />
      <item value="as well as" />
      <item value="wait And Drain" />
      <item value="a theoretical TCP transport" />
      <item value="A virtual connection to a conceptual endpoint, to perform RPCs. A channel is free to have zero or many actual connections to the endpoint based on configuration, load, etc. A channel is also free to determine which actual endpoints to use and may change it every RPC, permitting client-side load balancing. Applications are generally expected to use stubs instead of calling this class directly." />
      <item value="conceptual" />
      <item value="Clears this reference object and adds it to the queue with which it is registered, if any.&#10;This method is invoked only by Java code; when the garbage collector enqueues references it does so directly, without invoking this method." />
      <item value="Return true as a hint that there might be another Reference pending or false when there are no more pending References at the moment and the program can do some other useful work instead of looping." />
      <item value="robust" />
      <item value="General-purpose phantom-reference-based cleaners." />
      <item value="Tells whether or not this reference object has been enqueued, either by the program or by the garbage collector. If this reference object was not registered with a queue when it was created, then this method will always return false." />
      <item value="Subject" />
      <item value="really" />
      <item value="Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected." />
      <item value="Treated specially by GC" />
      <item value="Treated" />
      <item value="Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly" />
      <item value="Cleaners are a lightweight and more robust alternative to finalization" />
      <item value="&#10;For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value="Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. The behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified." />
      <item value="A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected.&#10;" />
      <item value="&#10;Private: Changes made to the resulting buffer will not be propagated to the file and will not be visible to other programs that have mapped the same file; instead, they will cause private copies of the modified portions of the buffer to be created. (MapMode.PRIVATE)" />
      <item value="Readwrite: Changes made to the resulting buffer will eventually be propagated to the file; they may or may not be made visible to other programs that have mapped the same file. (MapMode.READ_WRITE)" />
      <item value="Returns the byte array that backs this buffer  (optional operation)." />
      <item value="backs" />
      <item value="It is therefore strongly recommended that appropriate precautions be taken to avoid the manipulation of a mapped file by this program, or by a concurrently running program, except to read or write the file's content" />
      <item value="An attempt to access an inaccessible region of a mapped byte buffer will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time" />
      <item value="All or part of a mapped byte buffer may become inaccessible at any time," />
      <item value="Whether or not such changes occur, and when they occur, is operating-system dependent and therefore unspecified. " />
      <item value="A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected." />
      <item value="This method is potentially much more efficient than a simple loop that reads from this channel and writes to the target channel. Many operating systems can transfer bytes directly from the filesystem cache to the target channel without actually copying them.&#10;Params:&#10;" />
      <item value=" If the target channel has a position then bytes are written starting at that position and then the position is incremented by the number of bytes written." />
      <item value="        Double" />
      <item value="if the computation detectably attempts a recursive update to this map that would otherwise never complete" />
      <item value="lmdbjava.disable.extract" />
      <item value=" &#10;The combine function is used to compose the materialized values of this flow and that flow into the materialized value of the resulting Flow." />
      <item value="afterwards" />
      <item value="Initiates" />
      <item value="A context propagation mechanism which can carry scoped-values across API boundaries and between threads." />
      <item value="unambiguously" />
      <item value=" being relative causes them to be poorly suited for managing higher-level tasks where there are many components and sub-operations that may not know the time of the initial &quot;start of the operation" />
      <item value="Many systems use timeouts, which are relative to the start of the operatio" />
      <item value="passage" />
      <item value="An absolute point in time, generally for tracking when a task should be completed. A deadline is immutable except for the passage of time causing it to expire." />
      <item value="Ticker" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="83" />
        <entry key="ENGLISH" value="84" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1649835192138" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>