<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="proceed" />
      <item value="A decision to proceed the RPC on a Subchannel." />
      <item value="     An error to be propagated to the application if subchannel == null&#10;     Or OK if there is no error.&#10;     subchannel being null and error being OK means RPC needs to wait" />
      <item value="Buffer: in all other cases, the RPC will be buffered in the Channel, until the next picker is provided via Helper.updateBalancingState(), when the RPC will go through the same picking process again." />
      <item value="Proceed: if a Subchannel is provided via withSubchannel(), and is in READY state when the RPC tries to start on it, the RPC will proceed on that Subchannel." />
      <item value="If the new state is not SHUTDOWN, this method should create a new picker and call Helper.updateBalancingState(). Failing to do so may result in unnecessary delays of RPCs. Please refer to PickResult.withSubchannel()'s javadoc for more information." />
      <item value="You won't get a notification for the initial IDLE state" />
      <item value="No synchronization should be necessary between LoadBalancer and its pickers if you follow the pattern above. It may be possible to implement in a different way, but that would usually result in more complicated threading." />
      <item value="A typical SubchannelPicker holds a snapshot of these states. It may have its own states, e.g., a picker from a round-robin load-balancer may keep a pointer to the next Subchannel, which are typically mutated by multiple threads. The picker should only mutate its own state, and should not mutate or re-acquire the states of the LoadBalancer. This way the picker only needs to synchronize its own states, which is typically trivial to implement." />
      <item value="&#10;A LoadBalancer keeps states like the latest addresses from NameResolver, the Subchannel(s) and their latest connectivity states. These states are mutated within the Synchronization Context," />
      <item value="mutated" />
      <item value="The canonical implementation pattern" />
      <item value="Examples or work that must be avoided: CPU-intensive calculation, waiting on synchronization primitives, blocking IO, blocking RPCs, etc." />
      <item value="Helper is implemented by gRPC library and provided to Factory. It provides functionalities that a LoadBalancer implementation would typically need." />
      <item value="LoadBalancer is the main interface. All methods on it are invoked sequentially in the same synchronization context (see next section) as returned by io.grpc.LoadBalancer.Helper.getSynchronizationContext. It receives the results from the NameResolver, updates of subchannels' connectivity states, and the channel's request for the LoadBalancer to shutdown." />
      <item value="A LoadBalancer typically implements three interfaces" />
      <item value="Call LB only if it's not shutdown.  If LB is shutdown, lbHelper won't match." />
      <item value="The addresses and attributes of a target may be changed over time, thus the caller registers a NameResolver.Listener to receive continuous updates." />
      <item value="conceptual" />
      <item value="validate() emit a load-fence, but no store-fence." />
      <item value="Region" />
      <item value="Canonical" />
      <item value="get Local Canonical Host Name" />
      <item value="Region is the most basic kv data unit.  Each region has a left-closed&#10;  right-open interval range. " />
      <item value="Case insensitive keyvalue for replica constraints." />
      <item value="Placement driver client" />
      <item value="Range split operation" />
      <item value="Property that defines whether type identifier value will be passed as part of JSON stream to deserializer (true), or handled and removed by TypeDeserializer (false). Property has no effect on serialization.&#10;Default value is false, meaning that Jackson handles and removes the type identifier from JSON content that is passed to JsonDeserializer." />
      <item value="Definition of standard type inclusion mechanisms for type metadata. Used for standard metadata types, except for JsonTypeInfo.Id.NONE. May or may not be used for custom types (JsonTypeInfo.Id.CUSTOM)." />
      <item value="Means that typing mechanism uses customized handling, with possibly custom configuration. This means that semantics of other properties is not defined by Jackson package, but by the custom implementation." />
      <item value="Means that no serialized typing-property is used. Types are deduced based on the fields available. Deduction is limited to the names of fields (not their values or, consequently, any nested descendants). Exceptions will be thrown if not enough unique information is present to select a single subtype. If deduction is being used annotation properties visible, property and include are ignored." />
      <item value="Means that logical type name is used as type information; name will then need to be separately resolved to actual concrete type (Class)." />
      <item value="Reads a file's attributes as a bulk operation.&#10;" />
      <item value=" if a directory could not otherwise be created because a file of that name already exists (optional specific exception)" />
      <item value="&#10;This technique is particularly useful if a module takes a map on input, copies it, and later returns results whose order is determined by that of the copy. (Clients generally appreciate having things returned in the same order they were presented.)" />
      <item value="incurring" />
      <item value=" without incurring the increased cost associated with TreeMap" />
      <item value="This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashMap (and Hashtable), without incurring the increased cost associated with TreeMap. It can be used to produce a copy of a map that has the same order as the original, regardless of the original map's implementation" />
      <item value="This implementation spares its clients from the unspecified" />
      <item value=" Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)" />
      <item value=" This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). " />
      <item value="Hash table and linked list implementation of the Map interface, with predictable iteration order." />
      <item value="Specifies the maximum weight of entries the cache may contain." />
      <item value=" As eviction is scheduled on the configured executor, tests may instead prefer to configure the cache to execute tasks directly on the same thread.&#10;" />
      <item value=" For example, the cache may evict an entry because it hasn't been used recently or very often." />
      <item value="Specifies the maximum number of entries the cache may contain. Note that the cache may evict an entry before this limit is exceeded or temporarily exceed the threshold while evicting." />
      <item value="Specifies the maximum number of entries the cache may contain" />
      <item value="poll" />
      <item value="Memory consistency effects: Actions in a thread prior to submitting a task to a CompletionService happen-before actions taken by that task, which in turn happen-before actions following a successful return from the corresponding take()." />
      <item value="A CompletionService can for example be used to manage asynchronous IO, in which tasks that perform reads are submitted in one part of a program or system, and then acted upon in a different part of the program when the reads complete, possibly in a different order than they were requested.&#10;" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="430" />
        <entry key="ENGLISH" value="431" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1662038916988" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>