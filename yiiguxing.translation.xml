<application>
  <component name="AppStorage">
    <histories>
      <item value="eligible" />
      <item value="precisely" />
      <item value="Accessed via a benign data race; relies on the memory model's out-of-thin-air guarantees for references.&#10;This allows tracking of read holds for uncontended read locks to be very cheap." />
      <item value="relinquishing" />
      <item value="Cannot cause garbage retention unless the thread terminated without relinquishing its read locks, since tryReleaseShared sets it to null." />
      <item value="&#10;More precisely, firstReader is the unique thread that last changed the shared count from 0 to 1, and has not released the read lock since then; null if there is no such thread." />
      <item value="More precisely" />
      <item value="Acquires only if reentrant or queue is empty." />
      <item value="A synchronizer that may be exclusively owned by a thread. This class provides a basis for creating locks and related synchronizers that may entail a notion of ownership. The AbstractOwnableSynchronizer class itself does not manage or use this information. However, subclasses and tools may use appropriately maintained values to help control and monitor access and provide diagnostics." />
      <item value="true if synchronization is held exclusively;" />
      <item value="Returns true if synchronization is held exclusively with respect to the current (calling) thread. This method is invoked upon each call to a AbstractQueuedSynchronizer.ConditionObject method." />
      <item value="If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens" />
      <item value="Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one." />
      <item value="In addition to" />
      <item value="&#10;In addition to implementing the Lock interface, this class defines a number of public and protected methods for inspecting the state of the lock. Some of these methods are only useful for instrumentation and monitoring." />
      <item value="&#10;The constructor for this class accepts an optional fairness parameter. When set true, under contention, locks favor granting access to the longest-waiting thread." />
      <item value="A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities." />
      <item value="This class does not impose a reader or writer preference ordering for lock access. However, it does support an optional fairness policy." />
      <item value="It should be called from the Synchronization Context. Currently will log a warning if violated. It will become an exception eventually. See 5015  for the background." />
      <item value="If there isn't an active transport yet, and an RPC is assigned to the Subchannel, it will create a new transport. It won't actively create transports otherwise. requestConnection() can be used to ask Subchannel to create a transport if there isn't any.&#10;" />
      <item value="It maintains at most one physical connection (aka transport) for sending new RPCs, while also keeps track of previous transports that has been shut down but not terminated yet." />
      <item value="A logical connection to a server, or a group of equivalent servers represented by an EquivalentAddressGrou" />
      <item value="This transport owns every stream that it has created until a real transport has been picked for that stream, at which point the ownership of the stream is transferred to the real transport, thus the delayed transport stops owning the stream" />
      <item value="When reprocess is called, this class applies the provided io.grpc.LoadBalancer.SubchannelPicker to pick a transport for each pending stream" />
      <item value="&#10;a Runnable that is executed after-the-fact by the original caller, typically after locks are released" />
      <item value="Implementations must not call listener from within start; implementations are expected to notify listener on a separate thread or when the returned Runnable is run. This method and the returned Runnable should not throw any exceptions." />
      <item value="An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new RunnableTask()).start() for each of a set of tasks" />
      <item value="Internal Instrumented" />
      <item value="drain" />
      <item value="When a buffer is added to a composite, its life cycle is controlled by the composite. Once the composite has read past the end of a given buffer, that buffer is automatically closed and removed from the composite." />
      <item value="A ReadableBuffer that is composed of 0 or more ReadableBuffers." />
      <item value="Deframer for GRPC frames." />
      <item value="frames" />
      <item value="Deframer" />
      <item value="Delayed" />
      <item value="&#10;Guava implementations of ListenableFuture promptly release references to listeners after executing them" />
      <item value="Memory consistency effects: Actions in a thread prior to adding a listener happen-before its execution begins, perhaps in another thread." />
      <item value="This is the most general listener interface. For common operations performed using listeners, see Futures. For a simplified but general listener interface, see addCallback()." />
      <item value="Note: If your listener is lightweight -- and will not cause stack overflow by completing more futures or adding more directExecutor() listeners inline -- consider MoreExecutors.directExecutor. Otherwise, avoid it: See the warnings on the docs for directExecutor." />
      <item value="There is no guaranteed ordering of execution of listeners, but any listener added through this method is guaranteed to be called once the computation is complete." />
      <item value="There is a race between cancel and the completionfailure of the RPC in other ways. If cancel won the race, Listener.onClose() is called with CANCELLED. Otherwise, Listener.onClose() is called with whatever status the RPC was finished. We ensure that at most one is called." />
      <item value="There is no interaction between the states on the Listener and ClientCall, i.e., if Listener.onClose() is called, it has no bearing on the permitted operations on ClientCall (but it may impact whether they do anything)." />
      <item value="No generic method for determining message receipt or providing acknowledgement is provided. Applications are expected to utilize normal payload messages for such signals, as a response naturally acknowledges its request." />
      <item value="More advanced usages may consume this interface directly as opposed to using a stub. " />
      <item value="If true, indicates that the observer is capable of sending additional messages without requiring excessive buffering internally. This value is just a suggestion and the application is free to ignore it, however doing so may result in excessive buffering within the observer." />
      <item value="This is implemented by the client application and passed into a service method on a stub object." />
      <item value="In any call there are logically four StreamObserver implementations:" />
      <item value="A refinement of StreamObserver provided by the GRPC runtime to the application (the client or the server) that allows for more complex interactions with call behavior." />
      <item value="refinement " />
      <item value="refinement" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="209" />
        <entry key="ENGLISH" value="210" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1657497824818" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>