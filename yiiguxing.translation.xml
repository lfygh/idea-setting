<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Performs cleanup and bookkeeping for a dying worker. Called only from worker threads. Unless completedAbruptly is set, assumes that workerCount has already been adjusted to account for exit. This method removes thread from worker set, and possibly terminates the pool or replaces the worker if either it exited due to user task exception or if fewer than corePoolSize workers are running or queue is non-empty but there are no workers." />
      <item value="completed Abruptly" />
      <item value="dying" />
      <item value="Performs cleanup and bookkeeping for a dying worker." />
      <item value="If abrupt, then workerCount wasn't adjusted" />
      <item value="Method invoked prior to executing the given Runnable in the given thread. This method is invoked by thread t that will execute task r, and may be used to re-initialize ThreadLocals, or to perform logging.&#10;This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke super.beforeExecute at the end of this method." />
      <item value="A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false." />
      <item value="After task.run completes, we call afterExecute, which may also throw an exception, which will also cause thread to die. According to JLS Sec 14.20, this exception is the one that will be in effect even if task.run throws. The net effect of the exception mechanics is that afterExecute and the thread's UncaughtExceptionHandler have as accurate information as we can provide about any problems encountered by user code." />
      <item value=" Assuming beforeExecute completes normally, we run the task, gathering any of its thrown exceptions to send to afterExecute. We separately handle RuntimeException, Error (both of which the specs guarantee that we trap) and arbitrary Throwables. Because we cannot rethrow Throwables within Runnable.run, we wrap them within Errors on the way out (to the thread's UncaughtExceptionHandler). Any thrown exception also conservatively causes thread to die." />
      <item value="Each task run is preceded by a call to beforeExecute, which might throw an exception, in which case we cause thread to die (breaking loop with completedAbruptly true) without processing the task." />
      <item value="preceded" />
      <item value=" Each task run is preceded by a call to beforeExecute, which might throw an exception, in which case we cause thread to die (breaking loop with completedAbruptly true) without processing the task." />
      <item value=" Before running any task, the lock is acquired to prevent other pool interrupts while the task is executing, and then we ensure that unless pool is stopping, this thread does not have its interrupt set." />
      <item value="We may start out with an initial task, in which case we don't need to get the first one. Otherwise, as long as pool is running, we get tasks from getTask. If it returns null then the worker exits due to changed pool state or configuration parameters. Other exits result from exception throws in external code, in which case completedAbruptly holds, which usually leads processWorkerExit to replace this thread. " />
      <item value="If it returns null then the worker exits due to changed pool state or configuration parameters." />
      <item value="while coping with a number of issues" />
      <item value="This worker timed out waiting for a task, and timed-out workers are subject to termination" />
      <item value="the task the new thread should run first (or null if none). Workers are created with an initial first task (in method execute()) to bypass queuing when there are fewer than corePoolSize threads (in which case we always start one), or when the queue is full (in which case we must bypass queue). Initially idle threads are usually created via prestartCoreThread or to replace other dying workers." />
      <item value="eligible to shut down" />
      <item value="eligible" />
      <item value="accordingly" />
      <item value="If so, the worker count is adjusted accordingly," />
      <item value="with respect to" />
      <item value="Checks if a new worker can be added with respect to current pool state and the given bound (either core or maximum)." />
      <item value="inhibit interrupts until runWorker" />
      <item value=" This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run" />
      <item value="opportunistically" />
      <item value="This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock surrounding each task execution." />
      <item value="bookkeeping" />
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping. " />
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping. T" />
      <item value="along with other minor bookkeeping." />
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks" />
      <item value="The queue used for holding tasks and handing off to worker threads. We do not require that workQueue.poll() returning null necessarily means that workQueue.isEmpty(), so rely solely on isEmpty to see if the queue is empty (which we must do for example when deciding whether to transition from SHUTDOWN to TIDYING). This accommodates special-purpose queues such as DelayQueues for which poll() is allowed to return null even if it may later return non-null when delays expire." />
      <item value="The queue used for holding tasks and handing off to worker threads. We do not require that workQueue.poll() returning null necessarily means that workQueue.isEmpty()," />
      <item value="relinquishes" />
      <item value="Sets head of queue, and checks if successor may be waiting in shared mode, if so propagating if either propagate &gt; 0 or PROPAGATE status was set." />
      <item value=" Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquireShared until success" />
      <item value="Acquires in shared mode, ignoring interrupts. Implemented by first invoking at least once tryAcquireShared, returning on success." />
      <item value="As a heuristic to avoid indefinite writer starvation" />
      <item value="barge" />
      <item value="Attempts to set the state to reflect a release in shared mode." />
      <item value="true if this release of shared mode may permit a waiting acquire (shared or exclusive) to succeed; and false otherwise" />
      <item value=" Decrement count; signal when transition to zero" />
      <item value="lies dormant " />
      <item value="dormant" />
      <item value="A useful property of a CountDownLatch is that it doesn't require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass." />
      <item value="versatile" />
      <item value=" This is a one-shot phenomenon -- the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier" />
      <item value="A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown method" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="265" />
        <entry key="ENGLISH" value="266" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1657497824818" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>