<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Placement driver client" />
      <item value="Range split operation" />
      <item value="Property that defines whether type identifier value will be passed as part of JSON stream to deserializer (true), or handled and removed by TypeDeserializer (false). Property has no effect on serialization.&#10;Default value is false, meaning that Jackson handles and removes the type identifier from JSON content that is passed to JsonDeserializer." />
      <item value="Definition of standard type inclusion mechanisms for type metadata. Used for standard metadata types, except for JsonTypeInfo.Id.NONE. May or may not be used for custom types (JsonTypeInfo.Id.CUSTOM)." />
      <item value="Means that typing mechanism uses customized handling, with possibly custom configuration. This means that semantics of other properties is not defined by Jackson package, but by the custom implementation." />
      <item value="Means that no serialized typing-property is used. Types are deduced based on the fields available. Deduction is limited to the names of fields (not their values or, consequently, any nested descendants). Exceptions will be thrown if not enough unique information is present to select a single subtype. If deduction is being used annotation properties visible, property and include are ignored." />
      <item value="Means that logical type name is used as type information; name will then need to be separately resolved to actual concrete type (Class)." />
      <item value="Reads a file's attributes as a bulk operation.&#10;" />
      <item value=" if a directory could not otherwise be created because a file of that name already exists (optional specific exception)" />
      <item value="&#10;This technique is particularly useful if a module takes a map on input, copies it, and later returns results whose order is determined by that of the copy. (Clients generally appreciate having things returned in the same order they were presented.)" />
      <item value="incurring" />
      <item value=" without incurring the increased cost associated with TreeMap" />
      <item value="This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashMap (and Hashtable), without incurring the increased cost associated with TreeMap. It can be used to produce a copy of a map that has the same order as the original, regardless of the original map's implementation" />
      <item value="This implementation spares its clients from the unspecified" />
      <item value=" Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)" />
      <item value=" This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). " />
      <item value="Hash table and linked list implementation of the Map interface, with predictable iteration order." />
      <item value="Specifies the maximum weight of entries the cache may contain." />
      <item value=" As eviction is scheduled on the configured executor, tests may instead prefer to configure the cache to execute tasks directly on the same thread.&#10;" />
      <item value=" For example, the cache may evict an entry because it hasn't been used recently or very often." />
      <item value="Specifies the maximum number of entries the cache may contain. Note that the cache may evict an entry before this limit is exceeded or temporarily exceed the threshold while evicting." />
      <item value="Specifies the maximum number of entries the cache may contain" />
      <item value="poll" />
      <item value="Memory consistency effects: Actions in a thread prior to submitting a task to a CompletionService happen-before actions taken by that task, which in turn happen-before actions following a successful return from the corresponding take()." />
      <item value="A CompletionService can for example be used to manage asynchronous IO, in which tasks that perform reads are submitted in one part of a program or system, and then acted upon in a different part of the program when the reads complete, possibly in a different order than they were requested.&#10;" />
      <item value="A service that decouples the production of new asynchronous tasks from the consumption of the results of completed tasks. " />
      <item value="monotonic Ms" />
      <item value="Runtime only dependencies for source set 'main'" />
      <item value="Iterator over a batch of committed tasks." />
      <item value="     The raft log used fsync by default, and the correctness of&#10;     state-machine data with rheakv depends on the raft log + snapshot,&#10;     so we do not need to fsync." />
      <item value="If the key definitely does not exist in the database, then this method returns false" />
      <item value="That is to say that this method is probabilistic and may return false positives, but never a false negative." />
      <item value="Schedules the specified TimerTask for one-time execution after the specified delay" />
      <item value="The main balancing logic. It must be thread-safe. Typically it should only synchronize on its own state, and avoid synchronizing with the LoadBalancer's state." />
      <item value="&#10;       The channel state does not get updated when doing name resolving today, so for the moment&#10;       let LB report CONNECTION and call subchannel.requestConnection() immediately." />
      <item value="Given the name of a host, returns an array of its IP addresses, based on the configured name service on the system.&#10;The host name can either be a machine name, such as &quot;www.example.com&quot;, or a textual representation of its IP address. If a literal IP address is supplied, only the validity of the address format is checked.&#10;" />
      <item value="An implementation must generate it without blocking, typically in line, and must keep it unchanged. NameResolvers created from the same factory with the same argument must return the same authority." />
      <item value="Returns the authority used to authenticate connections to servers. It must be from a trusted source, because if the authority is tampered with, RPCs may be sent to the attackers which may leak sensitive user data." />
      <item value="Returns the authority used to authenticate connections to servers" />
      <item value="Implementations don't need to be thread-safe. All methods are guaranteed to be called sequentially. Additionally, all methods that have side-effects, i.e., start(NameResolver.Listener2), shutdown and refresh are called from the same SynchronizationContext as returned by NameResolver.Args.getSynchronizationContext. Do not block within the synchronization context; blocking IO and time-consuming tasks should be offloaded to a separate thread, generally NameResolver.Args.getOffloadExecutor." />
      <item value="A NameResolver does not need to automatically re-resolve on failure. Instead, the NameResolver.Listener is responsible for eventually (after an appropriate backoff period) invoking refresh()." />
      <item value="A NameResolver uses the URI's scheme to determine whether it can resolve it, and uses the components after the scheme for actual resolution." />
      <item value="The channel state does not get updated when doing name resolving today, so for the moment&#10;       let LB report CONNECTION and call subchannel.requestConnection() immediately." />
      <item value="Conceptually, it is fairly accurate to think of SynchronizationContext like a cheaper Executors.newSingleThreadExecutor() when used for synchronization (not long-running tasks). Both use a queue for tasks that are run in order and neither guarantee that tasks have completed before returning from execute(). However, the behavior does diverge if locks are held when calling the context. So it is encouraged to avoid mixing locks and synchronization context except via executeLater.&#10;" />
      <item value=").&#10;Implementations don't need to be thread-safe. All methods are guaranteed to be called sequentially. Additionally, all methods that have side-effects, i.e., start(NameResolver.Listener2), shutdown and refresh are called from the same SynchronizationContext as returned by NameResolver.Args.getSynchronizationContext. Do not block within the synchronization context; blocking IO and time-consuming tasks should be offloaded to a separate thread, generally NameResolver.Args.getOffloadExecutor." />
      <item value="  exitIdleMode() may be called outside of inUseStateAggregator.handleNotInUse() while&#10;       isInUse() == false, in which case we still need to schedule the timer." />
      <item value="It doesn't own any thread. Tasks are run from caller's or caller-provided threads.&#10;Conceptually, it is fairly accurate to think of SynchronizationContext like a cheaper Executors.newSingleThreadExecutor() when used for synchronization (not long-running tasks). Both use a queue for tasks that are run in order and neither guarantee that tasks have completed before returning from execute(). However, the behavior does diverge if locks are held when calling the context. So it is encouraged to avoid mixing locks and synchronization context except via executeLater." />
      <item value="Non-reentrancy. If a task running in a synchronization context executes or schedules another task in the same synchronization context, the latter task will never run inline. It will instead be queued and run only after the current task has returned." />
      <item value="Ordering. Tasks are run in the same order as they are submitted via execute and executeLater.&#10;Serialization. Tasks are run in sequence and establish a happens-before relationship between them." />
      <item value="&#10;Providing authentication credentials is better served by CallCredentials. But a ClientInterceptor could set the CallCredentials within the CallOptions." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="405" />
        <entry key="ENGLISH" value="406" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1662038916988" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>