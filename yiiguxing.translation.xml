<application>
  <component name="AppStorage">
    <histories>
      <item value="offer" />
      <item value="&#10;Calling this method before start() or shutdown() is permitted and does not change its behavior." />
      <item value="Calling this method before start() or shutdown() is permitted and does not change its behavior." />
      <item value="If not already completed, causes invocations of get() and related methods to throw the given exception." />
      <item value="Partitioning schemes supported by operators." />
      <item value="Inexact" />
      <item value="roughly" />
      <item value="ExecutionPlan can be displayed in an simplified form using the return value from displayable in addition to the (normally quite verbose) Debug output." />
      <item value="Each ExecutionPlan is Partition-aware and is responsible for creating the actual async SendableRecordBatchStreams of RecordBatch that incrementally compute the operator's output from its input partition.&#10;" />
      <item value="Requests an element on the given port unless the port is already closed. Calling this method twice before an element arrived will fail. There can only be one outstanding request at any given time. The method () can be used query whether pull is allowed to be called or not." />
      <item value="For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value="Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. The behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified." />
      <item value="A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping." />
      <item value="Maps a region of this channel's file directly into memory." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected." />
      <item value="The behavior of the WeakHashMap class depends in part upon the actions of the garbage collector, so several familiar (though not required) Map invariants do not hold for this class. Because the garbage collector may discard keys at any time, a WeakHashMap may behave as though an unknown thread is silently removing entries. In particular, even if you synchronize on a WeakHashMap instance and invoke none of its mutator methods, it is possible for the size method to return smaller values over time, for the isEmpty method to return false and then true, for the containsKey method to return true and later false for a given key, for the get method to return a value for a given key but later return null, for the put method to return null and the remove method to return false for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements." />
      <item value="This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a lookup of that key in a WeakHashMap at some later time and be surprised that its entry has been removed. This class will work perfectly well with key objects whose equals methods are not based upon object identity, such as String instances. With such recreatable key objects, however, the automatic removal of WeakHashMap entries whose keys have been discarded may prove to be confusing." />
      <item value="This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a lookup of that key in a WeakHashMap at some later time and be surprised that its entry has been removed. This class will work perfectly well with key objects whose equals methods are not based upon object identity, such as String instances. With such recreatable key objects, however, the automatic removal of WeakHashMap entries whose keys have been discarded may prove to be confusing.&#10;" />
      <item value="Both null values and the null key are supported. This class has performance characteristics similar to those of the HashMap class, and has the same efficiency parameters of initial capacity and load factor.&#10;Like most collection classes, this class is not synchronized. A synchronized WeakHashMap may be constructed using the Collections.synchronizedMap method." />
      <item value="Hash table based implementation of the Map interface, with weak keys. An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. More precisely, the presence of a mapping for a given key will not prevent the key from being discarded by the garbage collector, that is, made finalizable, finalized, and then reclaimed. When a key has been discarded its entry is effectively removed from the map, so this class behaves somewhat differently from other Map implementations." />
      <item value="precisely" />
      <item value="More precisely" />
      <item value="refinement" />
      <item value="A refinement of StreamObserver provided by the GRPC runtime to the application (the client or the server) that allows for more complex interactions with call behavior." />
      <item value="This API is asynchronous, so methods may return before the operation completes. The API provides no guarantees for how quickly an operation will complete, so utilizing flow control via ClientCallStreamObserver and ServerCallStreamObserver to avoid excessive buffering is recommended for streaming RPCs. gRPC's implementation of onError() on client-side causes the RPC to be cancelled and discards all messages, so completes quickly." />
      <item value="Receives notifications from an observable stream of messages.&#10;" />
      <item value="Internal Instrumented" />
      <item value="as well as" />
      <item value="wait And Drain" />
      <item value="a theoretical TCP transport" />
      <item value="A virtual connection to a conceptual endpoint, to perform RPCs. A channel is free to have zero or many actual connections to the endpoint based on configuration, load, etc. A channel is also free to determine which actual endpoints to use and may change it every RPC, permitting client-side load balancing. Applications are generally expected to use stubs instead of calling this class directly." />
      <item value="conceptual" />
      <item value="Clears this reference object and adds it to the queue with which it is registered, if any.&#10;This method is invoked only by Java code; when the garbage collector enqueues references it does so directly, without invoking this method." />
      <item value="Return true as a hint that there might be another Reference pending or false when there are no more pending References at the moment and the program can do some other useful work instead of looping." />
      <item value="robust" />
      <item value="General-purpose phantom-reference-based cleaners." />
      <item value="Tells whether or not this reference object has been enqueued, either by the program or by the garbage collector. If this reference object was not registered with a queue when it was created, then this method will always return false." />
      <item value="Subject" />
      <item value="really" />
      <item value="Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected." />
      <item value="Treated specially by GC" />
      <item value="Treated" />
      <item value="Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly" />
      <item value="Cleaners are a lightweight and more robust alternative to finalization" />
      <item value="&#10;For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected.&#10;" />
      <item value="&#10;Private: Changes made to the resulting buffer will not be propagated to the file and will not be visible to other programs that have mapped the same file; instead, they will cause private copies of the modified portions of the buffer to be created. (MapMode.PRIVATE)" />
      <item value="Readwrite: Changes made to the resulting buffer will eventually be propagated to the file; they may or may not be made visible to other programs that have mapped the same file. (MapMode.READ_WRITE)" />
      <item value="Returns the byte array that backs this buffer  (optional operation)." />
      <item value="backs" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="106" />
        <entry key="ENGLISH" value="107" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1651729578315" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>