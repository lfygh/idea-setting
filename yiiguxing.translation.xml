<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Buffer Underflow Exception" />
      <item value="Conceptually" />
      <item value="the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often." />
      <item value="     Dummy reference queue, needed because the PhantomReference constructor&#10;     insists that we pass a queue.  Nothing will ever be placed on this queue&#10;     since the reference handler invokes cleaners explicitly." />
      <item value="trivial" />
      <item value="Nontrivial" />
      <item value="A cleaner tracks a referent object and encapsulates a thunk of arbitrary&#10;  cleanup code. " />
      <item value="a thunk of" />
      <item value="thunk" />
      <item value="robust" />
      <item value="Cleaners are a lightweight and more robust alternative to finalization." />
      <item value="General-purpose phantom-reference-based cleaners." />
      <item value="A given arbitrary object may also be attached to the buffer." />
      <item value="allocation Granularity" />
      <item value="For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value=" One of the constants READ_ONLY, READ_WRITE, or PRIVATE defined in the FileChannel.MapMode class, according to whether the file is to be mapped read-only, readwrite, or privately (copy-on-write), respectively, or an implementation specific map mode" />
      <item value="he behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified." />
      <item value="Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. " />
      <item value="A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected." />
      <item value=" The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected." />
      <item value="Changes made to the resulting buffer will not be propagated to the file and will not be visible to other programs that have mapped the same file; instead, they will cause private copies of the modified portions of the buffer to be created. (MapMode.PRIVATE)" />
      <item value="Maps a region of this channel's file directly into memory." />
      <item value="propagate" />
      <item value="COMPLIANCE" />
      <item value="GOVERNANCE" />
      <item value="Retention" />
      <item value="bypass Governance Mode" />
      <item value="&#10;The first byte read is stored into element b[0], the next one into b[1], and so on. The number of bytes read is, at most, equal to the length of b. Let k be the number of bytes actually read; these bytes will be stored in elements b[0] through b[k-1], leaving elements b[k] through b[b.length-1] unaffected." />
      <item value="Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown.&#10;" />
      <item value="branch free" />
      <item value="         Add the timeout to the timeout queue which will be processed on the next tick.&#10;         During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket." />
      <item value="Returns the current value of the running Java Virtual Machine's high-resolution time source" />
      <item value="We use 0 as an indicator for the uninitialized value here, so make sure it's not 0 when initialized." />
      <item value="             transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just&#10;             adds new timeouts in a loop." />
      <item value="VIRGIN" />
      <item value="obsolete" />
      <item value="Implementation note: This class scales to large numbers of concurrently scheduled tasks (thousands should present no problem). Internally, it uses a binary heap to represent its task queue, so the cost to schedule a task is O(log n), where n is the number of concurrently scheduled tasks." />
      <item value="&#10;Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the TimerTimerTask combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer." />
      <item value="However, this can take arbitrarily long to occur. By default, the task execution thread does not run as a daemon thread, so it is capable of keeping an application from terminating. If a caller wants to terminate a timer's task execution thread rapidly, the caller should invoke the timer's cancel method." />
      <item value="&#10;After the last live reference to a Timer object goes away and all outstanding tasks have completed execution, the timer's task execution thread terminates gracefully (and becomes subject to garbage collection). " />
      <item value="it &quot;hogs&quot; the timer's task execution thread. This can, in turn, delay the execution of subsequent tasks, which may &quot;bunch up&quot; and execute in rapid succession when (and if) the offending task finally completes." />
      <item value="Corresponding to each Timer object is a single background thread that is used to execute all of the timer's tasks," />
      <item value="Alt Result" />
      <item value="To better conform with the use of common functional forms" />
      <item value="the use of common functional forms," />
      <item value="                 The peer contains logs from old term which should be truncated,&#10;                 decrease _last_log_at_peer by one to test the right index to keep" />
      <item value="   The accuracy is 100, don't ask more" />
      <item value="damn" />
      <item value="This is a sad code, the performance is too damn bad" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="516" />
        <entry key="ENGLISH" value="517" />
        <entry key="DANISH" value="1" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1663405920500" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>