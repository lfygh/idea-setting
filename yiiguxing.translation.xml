<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="It doesn't own any thread. Tasks are run from caller's or caller-provided threads.&#10;Conceptually, it is fairly accurate to think of SynchronizationContext like a cheaper Executors.newSingleThreadExecutor() when used for synchronization (not long-running tasks). Both use a queue for tasks that are run in order and neither guarantee that tasks have completed before returning from execute(). However, the behavior does diverge if locks are held when calling the context. So it is encouraged to avoid mixing locks and synchronization context except via executeLater." />
      <item value="Non-reentrancy. If a task running in a synchronization context executes or schedules another task in the same synchronization context, the latter task will never run inline. It will instead be queued and run only after the current task has returned." />
      <item value="Ordering. Tasks are run in the same order as they are submitted via execute and executeLater.&#10;Serialization. Tasks are run in sequence and establish a happens-before relationship between them." />
      <item value="&#10;Providing authentication credentials is better served by CallCredentials. But a ClientInterceptor could set the CallCredentials within the CallOptions." />
      <item value="Interface for intercepting outgoing calls before they are dispatched by a Channel." />
      <item value="Spying" />
      <item value="&#10;A NameResolver does not need to automatically re-resolve on failure. Instead, the NameResolver.Listener is responsible for eventually (after an appropriate backoff period) invoking refresh()." />
      <item value="hedging" />
      <item value="update configuration after _log_manager updated its memory status" />
      <item value="                     The change of term indicates that leader has been changed during&#10;                     appending entries, so we can't respond ok to the old leader&#10;                     because we are not sure if the appended logs would be truncated&#10;                     by the new leader:&#10;                      - If they won't be truncated and we respond failure to the old&#10;                        leader, the new leader would know that they are stored in this&#10;                        peer and they will be eventually committed when the new leader&#10;                        found that quorum of the cluster have stored.&#10;                      - If they will be truncated and we responded success to the old&#10;                        leader, the old leader would possibly regard those entries as&#10;                        committed (very likely in a 3-nodes cluster) and respond&#10;                        success to the clients, which would break the rule that&#10;                        committed entries would never be truncated.&#10;                     So we have to respond failure to the old leader and set the new&#10;                     term to make it stepped down if it didn't." />
      <item value="&#10;                 The log at prev_log_index has been compacted, which indicates&#10;                 we is or is going to install snapshot to the follower. So we let&#10;                 both prev_log_index and prev_log_term be 0 in the heartbeat&#10;                 request so that follower would do nothing besides updating its&#10;                 leader timestamp." />
      <item value="ELEADERCONFLICT" />
      <item value="set task entry info before adding to list" />
      <item value="Reject this task if expectedTerm doesn't match the current term of this Node if the value is not -1, default is -1" />
      <item value="Start follower's replicators" />
      <item value="signal fsm leader stop immediately" />
      <item value="EHIGHERTERMRESPONSE" />
      <item value="noinspection ConstantConditions" />
      <item value="A follower replicator may not be started when this node become leader, so we must check it." />
      <item value=" Node is currently the leader and |entries| are from the user who&#10;             don't know the correct indexes the logs should assign to. So we have&#10;             to assign indexes to the appending entries" />
      <item value="  Appending entries overlap the local ones. We should find if there&#10;                 is a conflicting index from which we should truncate the local&#10;                 ones." />
      <item value=" if have log using conf in log, else using conf in options" />
      <item value="Judge whether to launch a election." />
      <item value="for the performance consideration, we will take away the&#10;                    content. If you want keep the content, copy it before call&#10;                    this function" />
      <item value=" Most configurations do not need to be configured separately for each raft-group," />
      <item value="Lists incomplete object upload information of a bucket." />
      <item value="Sets default object retention in a bucket." />
      <item value="Gets presigned URL of an object for HTTP method, expiry time and custom request parameters." />
      <item value="Presigned" />
      <item value="Creates an object by combining data from different source objects using server-side copy." />
      <item value="Reads up to len bytes of data" />
      <item value="Only one write operation upon a writable channel may be in progress at any given time. If one thread initiates a write operation upon a channel then any other thread that attempts to initiate another write operation will block until the first operation is complete. Whether or not other kinds of IO operations may proceed concurrently with a write operation depends upon the type of the channel." />
      <item value="         If a buffer of this size is too large for the cache, there&#10;         should not be a buffer in the cache that is at least as&#10;         large. So we'll just create a new one. Also, we don't have&#10;         to remove the buffer from the cache (as this method does&#10;         below) given that we won't put the new buffer in the cache." />
      <item value="vice versa; " />
      <item value="&#10;This class defines methods for reading and writing values of all other primitive types, except boolean. Primitive values are translated to (or from) sequences of bytes according to the buffer's current byte order, which may be retrieved and modified via the order methods. Specific byte orders are represented by instances of the ByteOrder class. The initial order of a byte buffer is always BIG_ENDIAN." />
      <item value="&#10;Whether a byte buffer is direct or non-direct may be determined by invoking its isDirect method. This method is provided so that explicit buffer management can be done in performance-critical code. " />
      <item value="A direct byte buffer may also be created by mapping a region of a file directly into memory. An implementation of the Java platform may optionally support the creation of direct byte buffers from native code via JNI. If an instance of one of these kinds of buffers refers to an inaccessible region of memory then an attempt to access that region will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time." />
      <item value="A direct byte buffer may be created by invoking the allocateDirect factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system's native IO operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance." />
      <item value="A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native IO operations directly upon it. That is, it will attempt to avoid copying the buffer's content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system's native IO operations." />
      <item value="The first byte read is stored into element b[off], the next one into b[off+1], and so on. The number of bytes read is, at most, equal to len. Let k be the number of bytes actually read; these bytes will be stored in elements b[off] through b[off+k-1], leaving elements b[off+k] through b[off+len-1] unaffected.&#10;In every case, elements b[0] through b[off] and elements b[off+len] through b[b.length-1] are unaffected." />
      <item value="&#10;The first byte read is stored into element b[off], the next one into b[off+1]" />
      <item value="Reads up to len bytes of data from the input stream into an array of bytes. An attempt is made to read as many as len bytes, but a smaller number may be read. The number of bytes actually read is returned as an integer." />
      <item value="Whether or not a channel is registered with one or more selectors may be determined by invoking the isRegistered method." />
      <item value="A channel may be registered at most once with any particular selector." />
      <item value="A channel cannot be deregistered directly; instead, the key representing its registration must be cancelled. Cancelling a key requests that the channel be deregistered during the selector's next selection operation. A key may be cancelled explicitly by invoking its cancel method. All of a channel's keys are cancelled implicitly when the channel is closed, whether by invoking its close method or by interrupting a thread blocked in an IO operation upon the channel." />
      <item value="A channel cannot be deregistered directly; instead, the key representing its registration must be cancelled." />
      <item value="Once registered with a selector, a channel remains registered until it is deregistered. This involves deallocating whatever resources were allocated to the channel by the selector.&#10;" />
      <item value="&#10;In order to be used with a selector, an instance of this class must first be registered via the register method. This method returns a new SelectionKey object that represents the channel's registration with the selector." />
      <item value="In order to be used with a selector, an instance of this class must first be registered via the register method. This method returns a new SelectionKey object that represents the channel's registration with the selector." />
      <item value="A channel that can be multiplexed via a Selector." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="356" />
        <entry key="ENGLISH" value="357" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1660015985623" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>