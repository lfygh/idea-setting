<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="      The net effect of the exception mechanics is that afterExecute&#10;      and the thread's UncaughtExceptionHandler have as accurate&#10;      information as we can provide about any problems encountered by&#10;      user code." />
      <item value="Any thrown exception also&#10;      conservatively causes thread to die." />
      <item value="conservatively" />
      <item value="We separately handle RuntimeException, Error (both of which the&#10;      specs guarantee that we trap) and arbitrary Throwables." />
      <item value="a call to beforeExecute" />
      <item value="Each task run is preceded by a call to beforeExecute," />
      <item value="preceded" />
      <item value="Each task run is preceded by a call to beforeExecute" />
      <item value="Before running any task, the lock is acquired to prevent&#10;      other pool interrupts while the task is executing, and then we&#10;      ensure that unless pool is stopping, this thread does not have&#10;      its interrupt set." />
      <item value="If it returns null then the&#10;      worker exits due to changed pool state or configuration&#10;      parameters." />
      <item value="coping with a number of issues" />
      <item value="while coping with a number of issues" />
      <item value="Main worker run loop.  Repeatedly gets tasks from queue and&#10;      executes them, while coping with a number of issues" />
      <item value="Internal errors. Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken." />
      <item value="interest" />
      <item value="Transitions runState to given target, or leaves it alone if already at least the given target." />
      <item value="inhibit interrupts until runWorker" />
      <item value="Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty). If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate. This method must be called following any action that might make termination possible -- reducing worker count or removing tasks from the queue during shutdown. The method is non-private to allow access from ScheduledThreadPoolExecutor." />
      <item value="Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)." />
      <item value="This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using submit might be converted into a form that maintains Future status. However, in such cases, method purge may be used to remove those Futures that have been cancelled." />
      <item value="Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started.&#10;This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using submit might be converted into a form that maintains Future status. However, in such cases, method purge may be used to remove those Futures that have been cancelled." />
      <item value="Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started." />
      <item value="          2. If a task can be successfully queued, then we still need&#10;          to double-check whether we should have added a thread&#10;          (because existing ones died since last checking) or that&#10;          the pool shut down since entry into this method. So we&#10;          recheck state and if necessary roll back the enqueuing if&#10;          stopped, or start a new thread if there are none." />
      <item value="this method is generally preferable to add," />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception." />
      <item value=" violating" />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. " />
      <item value="&#10;poll" />
      <item value="BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future" />
      <item value="Performs cleanup and bookkeeping for a dying worker. Called only from worker threads. Unless completedAbruptly is set, assumes that workerCount has already been adjusted to account for exit. This method removes thread from worker set, and possibly terminates the pool or replaces the worker if either it exited due to user task exception or if fewer than corePoolSize workers are running or queue is non-empty but there are no workers." />
      <item value="completed Abruptly" />
      <item value="dying" />
      <item value="Performs cleanup and bookkeeping for a dying worker." />
      <item value="If abrupt, then workerCount wasn't adjusted" />
      <item value="Method invoked prior to executing the given Runnable in the given thread. This method is invoked by thread t that will execute task r, and may be used to re-initialize ThreadLocals, or to perform logging.&#10;This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke super.beforeExecute at the end of this method." />
      <item value="A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false." />
      <item value="After task.run completes, we call afterExecute, which may also throw an exception, which will also cause thread to die. According to JLS Sec 14.20, this exception is the one that will be in effect even if task.run throws. The net effect of the exception mechanics is that afterExecute and the thread's UncaughtExceptionHandler have as accurate information as we can provide about any problems encountered by user code." />
      <item value=" Assuming beforeExecute completes normally, we run the task, gathering any of its thrown exceptions to send to afterExecute. We separately handle RuntimeException, Error (both of which the specs guarantee that we trap) and arbitrary Throwables. Because we cannot rethrow Throwables within Runnable.run, we wrap them within Errors on the way out (to the thread's UncaughtExceptionHandler). Any thrown exception also conservatively causes thread to die." />
      <item value="Each task run is preceded by a call to beforeExecute, which might throw an exception, in which case we cause thread to die (breaking loop with completedAbruptly true) without processing the task." />
      <item value=" Each task run is preceded by a call to beforeExecute, which might throw an exception, in which case we cause thread to die (breaking loop with completedAbruptly true) without processing the task." />
      <item value=" Before running any task, the lock is acquired to prevent other pool interrupts while the task is executing, and then we ensure that unless pool is stopping, this thread does not have its interrupt set." />
      <item value="We may start out with an initial task, in which case we don't need to get the first one. Otherwise, as long as pool is running, we get tasks from getTask. If it returns null then the worker exits due to changed pool state or configuration parameters. Other exits result from exception throws in external code, in which case completedAbruptly holds, which usually leads processWorkerExit to replace this thread. " />
      <item value="If it returns null then the worker exits due to changed pool state or configuration parameters." />
      <item value="This worker timed out waiting for a task, and timed-out workers are subject to termination" />
      <item value="the task the new thread should run first (or null if none). Workers are created with an initial first task (in method execute()) to bypass queuing when there are fewer than corePoolSize threads (in which case we always start one), or when the queue is full (in which case we must bypass queue). Initially idle threads are usually created via prestartCoreThread or to replace other dying workers." />
      <item value="eligible to shut down" />
      <item value="eligible" />
      <item value="accordingly" />
      <item value="If so, the worker count is adjusted accordingly," />
      <item value="with respect to" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="295" />
        <entry key="ENGLISH" value="296" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658102165301" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>