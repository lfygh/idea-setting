<application>
  <component name="AppStorage">
    <histories>
      <item value="detached" />
      <item value="Checks and updates status for a node that failed to acquire. Returns true if thread should block. This is the main signal control in all acquire loops. Requires that pred == node.prev." />
      <item value="Acquires in exclusive uninterruptible mode for thread already in queue. Used by condition wait methods as well as acquire." />
      <item value="the acquire argument. This value is conveyed to tryAcquire but is otherwise uninterpreted and can represent anything you like." />
      <item value="Acquires in exclusive mode, ignoring interrupts. Implemented by invoking at least once tryAcquire, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success. This method can be used to implement method Lock.lock." />
      <item value="The current owner of exclusive mode synchronization." />
      <item value="Retrieve a single stream associated with a particular descriptor&#10;       associated with the referenced ticket. A Flight can be composed of one or&#10;       more streams where each stream can be retrieved using a separate opaque&#10;       ticket that the flight service uses for managing a collection of streams." />
      <item value="Flight services can support an arbitrary number of simple actions in&#10;       addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut&#10;       operations that are potentially available. DoAction allows a flight client&#10;       to do a specific action against a flight service. An action includes&#10;       opaque request and response objects that are specific to the type action&#10;       being undertaken." />
      <item value="POJO representation of a RecordBatch IPC message (https:arrow.apache.orgdocsformatIPC.html)." />
      <item value="RPC-layer hints for this call." />
      <item value="The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object." />
      <item value="Note that only the locks on this object are relinquished; any other objects on which the current thread may be synchronized remain locked while the thread waits." />
      <item value="relinquish" />
      <item value="This method causes the current thread (referred to here as T) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object." />
      <item value="The current thread must own this object's monitor lock. See the notify method for a description of the ways in which a thread can become the owner of a monitor lock." />
      <item value="The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object." />
      <item value="The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object." />
      <item value="Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation." />
      <item value="If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException." />
      <item value="Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception." />
      <item value="Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. " />
      <item value="Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.&#10;If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.&#10;If this thread is blocked in an IO operation upon an InterruptibleChannel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.&#10;If this thread is blocked in a java.nio.channels.Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked." />
      <item value="Interrupting a thread that is not alive need not have any effect." />
      <item value="If none of the previous conditions hold then this thread's interrupt status will be set." />
      <item value="     The object in which this thread is blocked in an interruptible IO&#10;      operation, if any.  The blocker's interrupt method should be invoked&#10;      after setting this thread's interrupt status." />
      <item value="passed up the call stack " />
      <item value="Code within a different context can subsequently call the checkPermission method on the previously-saved AccessControlContext object. A sample call is the following:" />
      <item value="More specifically, it encapsulates a context and has a single method, checkPermission, that is equivalent to the checkPermission method in the AccessController class, with one difference: The AccessControlContext checkPermission method makes access decisions based on the context it encapsulates, rather than that of the current execution thread." />
      <item value="More specifically" />
      <item value="An AccessControlContext is used to make system resource access decisions based on the context it encapsulates." />
      <item value="Create or append a descriptor with another stream." />
      <item value="turbofish" />
      <item value="&#10;Using the 'turbofish' instead of annotating doubled" />
      <item value="offer" />
      <item value="&#10;Calling this method before start() or shutdown() is permitted and does not change its behavior." />
      <item value="Calling this method before start() or shutdown() is permitted and does not change its behavior." />
      <item value="If not already completed, causes invocations of get() and related methods to throw the given exception." />
      <item value="Partitioning schemes supported by operators." />
      <item value="Inexact" />
      <item value="roughly" />
      <item value="ExecutionPlan can be displayed in an simplified form using the return value from displayable in addition to the (normally quite verbose) Debug output." />
      <item value="Each ExecutionPlan is Partition-aware and is responsible for creating the actual async SendableRecordBatchStreams of RecordBatch that incrementally compute the operator's output from its input partition.&#10;" />
      <item value="Requests an element on the given port unless the port is already closed. Calling this method twice before an element arrived will fail. There can only be one outstanding request at any given time. The method () can be used query whether pull is allowed to be called or not." />
      <item value="For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value="Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. The behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified." />
      <item value="A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping." />
      <item value="Maps a region of this channel's file directly into memory." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected." />
      <item value="The behavior of the WeakHashMap class depends in part upon the actions of the garbage collector, so several familiar (though not required) Map invariants do not hold for this class. Because the garbage collector may discard keys at any time, a WeakHashMap may behave as though an unknown thread is silently removing entries. In particular, even if you synchronize on a WeakHashMap instance and invoke none of its mutator methods, it is possible for the size method to return smaller values over time, for the isEmpty method to return false and then true, for the containsKey method to return true and later false for a given key, for the get method to return a value for a given key but later return null, for the put method to return null and the remove method to return false for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements." />
      <item value="This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a lookup of that key in a WeakHashMap at some later time and be surprised that its entry has been removed. This class will work perfectly well with key objects whose equals methods are not based upon object identity, such as String instances. With such recreatable key objects, however, the automatic removal of WeakHashMap entries whose keys have been discarded may prove to be confusing." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="139" />
        <entry key="ENGLISH" value="140" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1653731034141" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>