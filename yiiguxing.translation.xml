<application>
  <component name="AppStorage">
    <histories>
      <item value="Tells whether or not this reference object has been enqueued, either by the program or by the garbage collector. If this reference object was not registered with a queue when it was created, then this method will always return false." />
      <item value="Subject" />
      <item value="really" />
      <item value="Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected." />
      <item value="Treated specially by GC" />
      <item value="Treated" />
      <item value="Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly" />
      <item value="robust" />
      <item value="Cleaners are a lightweight and more robust alternative to finalization" />
      <item value="&#10;For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value="Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. The behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified." />
      <item value="A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected.&#10;" />
      <item value="&#10;Private: Changes made to the resulting buffer will not be propagated to the file and will not be visible to other programs that have mapped the same file; instead, they will cause private copies of the modified portions of the buffer to be created. (MapMode.PRIVATE)" />
      <item value="Readwrite: Changes made to the resulting buffer will eventually be propagated to the file; they may or may not be made visible to other programs that have mapped the same file. (MapMode.READ_WRITE)" />
      <item value="Returns the byte array that backs this buffer  (optional operation)." />
      <item value="backs" />
      <item value="It is therefore strongly recommended that appropriate precautions be taken to avoid the manipulation of a mapped file by this program, or by a concurrently running program, except to read or write the file's content" />
      <item value="An attempt to access an inaccessible region of a mapped byte buffer will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time" />
      <item value="All or part of a mapped byte buffer may become inaccessible at any time," />
      <item value="Whether or not such changes occur, and when they occur, is operating-system dependent and therefore unspecified. " />
      <item value="A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected." />
      <item value="This method is potentially much more efficient than a simple loop that reads from this channel and writes to the target channel. Many operating systems can transfer bytes directly from the filesystem cache to the target channel without actually copying them.&#10;Params:&#10;" />
      <item value=" If the target channel has a position then bytes are written starting at that position and then the position is incremented by the number of bytes written." />
      <item value="        Double" />
      <item value="if the computation detectably attempts a recursive update to this map that would otherwise never complete" />
      <item value="lmdbjava.disable.extract" />
      <item value=" &#10;The combine function is used to compose the materialized values of this flow and that flow into the materialized value of the resulting Flow." />
      <item value="afterwards" />
      <item value="Initiates" />
      <item value="A context propagation mechanism which can carry scoped-values across API boundaries and between threads." />
      <item value="unambiguously" />
      <item value=" being relative causes them to be poorly suited for managing higher-level tasks where there are many components and sub-operations that may not know the time of the initial &quot;start of the operation" />
      <item value="Many systems use timeouts, which are relative to the start of the operatio" />
      <item value="passage" />
      <item value="An absolute point in time, generally for tracking when a task should be completed. A deadline is immutable except for the passage of time causing it to expire." />
      <item value="Ticker" />
      <item value="drained" />
      <item value="Partial" />
      <item value=" the number of messages able to delivered will be the sum of the calls" />
      <item value="bypass" />
      <item value="f it is desired to bypass inbound flow control, a very large number of messages can be specified (e.g. Integer.MAX_VALUE)." />
      <item value="inbound" />
      <item value="spurious" />
      <item value="excessive" />
      <item value="This indicates that the ClientCall may now be capable of sending additional messages (via sendMessage) without requiring excessive buffering internally" />
      <item value="trailers" />
      <item value="The ClientCall has been closed. Any additional calls to the ClientCall will not be processed by the server. No further receiving will occur and no further notifications will be made." />
      <item value="Since Metadata is not thread-safe, the caller must not access (read or write) headers after this point." />
      <item value="Headers always precede messages." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="69" />
        <entry key="ENGLISH" value="70" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1649239617662" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>