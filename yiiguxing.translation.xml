<application>
  <component name="AppStorage">
    <histories>
      <item value="robust" />
      <item value="Cleaners are a lightweight and more robust alternative to finalization" />
      <item value="&#10;For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value="Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. The behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified." />
      <item value="A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected.&#10;" />
      <item value="&#10;Private: Changes made to the resulting buffer will not be propagated to the file and will not be visible to other programs that have mapped the same file; instead, they will cause private copies of the modified portions of the buffer to be created. (MapMode.PRIVATE)" />
      <item value="Readwrite: Changes made to the resulting buffer will eventually be propagated to the file; they may or may not be made visible to other programs that have mapped the same file. (MapMode.READ_WRITE)" />
      <item value="Returns the byte array that backs this buffer  (optional operation)." />
      <item value="backs" />
      <item value="It is therefore strongly recommended that appropriate precautions be taken to avoid the manipulation of a mapped file by this program, or by a concurrently running program, except to read or write the file's content" />
      <item value="An attempt to access an inaccessible region of a mapped byte buffer will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time" />
      <item value="All or part of a mapped byte buffer may become inaccessible at any time," />
      <item value="Whether or not such changes occur, and when they occur, is operating-system dependent and therefore unspecified. " />
      <item value="A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected." />
      <item value="This method is potentially much more efficient than a simple loop that reads from this channel and writes to the target channel. Many operating systems can transfer bytes directly from the filesystem cache to the target channel without actually copying them.&#10;Params:&#10;" />
      <item value=" If the target channel has a position then bytes are written starting at that position and then the position is incremented by the number of bytes written." />
      <item value="        Double" />
      <item value="if the computation detectably attempts a recursive update to this map that would otherwise never complete" />
      <item value="lmdbjava.disable.extract" />
      <item value=" &#10;The combine function is used to compose the materialized values of this flow and that flow into the materialized value of the resulting Flow." />
      <item value="afterwards" />
      <item value="Initiates" />
      <item value="A context propagation mechanism which can carry scoped-values across API boundaries and between threads." />
      <item value="unambiguously" />
      <item value=" being relative causes them to be poorly suited for managing higher-level tasks where there are many components and sub-operations that may not know the time of the initial &quot;start of the operation" />
      <item value="Many systems use timeouts, which are relative to the start of the operatio" />
      <item value="passage" />
      <item value="An absolute point in time, generally for tracking when a task should be completed. A deadline is immutable except for the passage of time causing it to expire." />
      <item value="Ticker" />
      <item value="drained" />
      <item value="Partial" />
      <item value=" the number of messages able to delivered will be the sum of the calls" />
      <item value="bypass" />
      <item value="f it is desired to bypass inbound flow control, a very large number of messages can be specified (e.g. Integer.MAX_VALUE)." />
      <item value="inbound" />
      <item value="spurious" />
      <item value="excessive" />
      <item value="This indicates that the ClientCall may now be capable of sending additional messages (via sendMessage) without requiring excessive buffering internally" />
      <item value="trailers" />
      <item value="The ClientCall has been closed. Any additional calls to the ClientCall will not be processed by the server. No further receiving will occur and no further notifications will be made." />
      <item value="Since Metadata is not thread-safe, the caller must not access (read or write) headers after this point." />
      <item value="Headers always precede messages." />
      <item value=" thread-hostile" />
      <item value="The following snippet demonstrates a bi-directional streaming case, where the client sends requests produced by a fictional makeNextRequest() in a flow-control-compliant manner, and notifies gRPC library to receive additional response after one is consumed by a fictional processResponse()" />
      <item value="There is a race between cancel and the completionfailure of the RPC in other ways. If cancel won the race, Listener.onClose() is called with CANCELLED. Otherwise, Listener.onClose() is called with whatever status the RPC was finished. We ensure that at most one is called." />
      <item value=" it has no bearing on the permitted operations on ClientCall (but it may impact whether they do anything)" />
      <item value="Methods are guaranteed to be non-blocking. Not thread-safe except for request, which may be called from any thread.&#10;" />
      <item value="No generic method for determining message receipt or providing acknowledgement is provided. Applications are expected to utilize normal payload messages for such signals, as a response naturally acknowledges its request.&#10;" />
      <item value=", with the exception of " />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="62" />
        <entry key="ENGLISH" value="63" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1649239617662" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>