<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Captures the state of the database in the latest backup" />
      <item value=" execute periodically." />
      <item value="Treiber stack of waiting threads" />
      <item value="A Future that is Runnable. Successful execution of the run method causes completion of the Future and allows access to its results." />
      <item value="SERIAL" />
      <item value="Cypher" />
      <item value="on Spin Wait" />
      <item value="consecutive Error Times" />
      <item value="Durations" />
      <item value="true if and only if the file or directory denoted by this abstract pathname exists;" />
      <item value="If 'read index' read fails, try to applying to the state machine at the leader node" />
      <item value="replete" />
      <item value="Boundary Event" />
      <item value="    There are two main functions of a Cell: message queueing and child lookup.&#10;    When switching out the UnstartedCell for its real replacement, the former&#10;    must be switched after all messages have been drained from the temporary&#10;    queue into the real mailbox, while the latter must be switched before&#10;    processing the very first message (i.e. before Cell.start()). Hence there&#10;    are two refs here, one for each function, and they are switched just so." />
      <item value="                 It's very messy to deal with the case when the |peer| received&#10;                 TimeoutNowRequest and increase the term while somehow another leader&#10;                 which was not replicated with the newest configuration has been&#10;                 elected. If no add_peer with this very |peer| is to be invoked ever&#10;                 after nor this peer is to be killed, this peer will spin in the voting&#10;                 procedure and make the each new leader stepped down when the peer&#10;                 reached vote timeout and it starts to vote (because it will increase&#10;                 the term of the group)&#10;                 To make things simple, refuse the operation and force users to&#10;                 invoke transfer_leadership_to after configuration changing is&#10;                 completed so that the peer's configuration is up-to-date when it&#10;                 receives the TimeOutNowRequest." />
      <item value="Set the maximum amount of direct memory.  This value is controlled&#10;         by the vm option -XX:MaxDirectMemorySize=&lt;size&gt;.&#10;         The maximum amount of allocatable direct buffer memory (in bytes)&#10;         from the system property sun.nio.MaxDirectMemorySize set by the VM.&#10;         The system property will be removed." />
      <item value="&#10;     Save a private copy of the system properties and remove&#10;     the system properties that are not intended for public access.&#10;    &#10;     This method can only be invoked during system initialization." />
      <item value="save And Remove Properties" />
      <item value="     A user-settable upper limit on the maximum amount of allocatable direct&#10;     buffer memory.  This value may be changed during VM initialization if&#10;     &quot;java&quot; is launched with &quot;-XX:MaxDirectMemorySize=&lt;size&gt;&quot;.&#10;    &#10;     The initial value of this field is arbitrary; during JRE initialization&#10;     it will be reset to the value specified on the command line, if any,&#10;     otherwise to Runtime.getRuntime().maxMemory()." />
      <item value="Buffer Underflow Exception" />
      <item value="Conceptually" />
      <item value="the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often." />
      <item value="     Dummy reference queue, needed because the PhantomReference constructor&#10;     insists that we pass a queue.  Nothing will ever be placed on this queue&#10;     since the reference handler invokes cleaners explicitly." />
      <item value="trivial" />
      <item value="Nontrivial" />
      <item value="A cleaner tracks a referent object and encapsulates a thunk of arbitrary&#10;  cleanup code. " />
      <item value="a thunk of" />
      <item value="thunk" />
      <item value="robust" />
      <item value="Cleaners are a lightweight and more robust alternative to finalization." />
      <item value="General-purpose phantom-reference-based cleaners." />
      <item value="A given arbitrary object may also be attached to the buffer." />
      <item value="allocation Granularity" />
      <item value="For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value=" One of the constants READ_ONLY, READ_WRITE, or PRIVATE defined in the FileChannel.MapMode class, according to whether the file is to be mapped read-only, readwrite, or privately (copy-on-write), respectively, or an implementation specific map mode" />
      <item value="he behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified." />
      <item value="Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. " />
      <item value="A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected." />
      <item value=" The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected." />
      <item value="Changes made to the resulting buffer will not be propagated to the file and will not be visible to other programs that have mapped the same file; instead, they will cause private copies of the modified portions of the buffer to be created. (MapMode.PRIVATE)" />
      <item value="Maps a region of this channel's file directly into memory." />
      <item value="propagate" />
      <item value="COMPLIANCE" />
      <item value="GOVERNANCE" />
      <item value="Retention" />
      <item value="bypass Governance Mode" />
      <item value="&#10;The first byte read is stored into element b[0], the next one into b[1], and so on. The number of bytes read is, at most, equal to the length of b. Let k be the number of bytes actually read; these bytes will be stored in elements b[0] through b[k-1], leaving elements b[k] through b[b.length-1] unaffected." />
      <item value="Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown.&#10;" />
      <item value="branch free" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="520" />
        <entry key="ENGLISH" value="521" />
        <entry key="DANISH" value="1" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1664204311345" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>