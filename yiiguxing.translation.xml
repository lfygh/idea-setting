<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Finds the resource with the given name. A resource is some data (images, audio, text, etc) that can be accessed by class code in a way that is independent of the location of the code.&#10;" />
      <item value="Finds the resource with the given name. A resource is some data (images, audio, text, etc) that can be accessed by class code in a way that is independent of the location of the code." />
      <item value="Captures the state of the database in the latest backup" />
      <item value=" execute periodically." />
      <item value="Treiber stack of waiting threads" />
      <item value="A Future that is Runnable. Successful execution of the run method causes completion of the Future and allows access to its results." />
      <item value="SERIAL" />
      <item value="Cypher" />
      <item value="on Spin Wait" />
      <item value="consecutive Error Times" />
      <item value="Durations" />
      <item value="true if and only if the file or directory denoted by this abstract pathname exists;" />
      <item value="If 'read index' read fails, try to applying to the state machine at the leader node" />
      <item value="replete" />
      <item value="Boundary Event" />
      <item value="    There are two main functions of a Cell: message queueing and child lookup.&#10;    When switching out the UnstartedCell for its real replacement, the former&#10;    must be switched after all messages have been drained from the temporary&#10;    queue into the real mailbox, while the latter must be switched before&#10;    processing the very first message (i.e. before Cell.start()). Hence there&#10;    are two refs here, one for each function, and they are switched just so." />
      <item value="                 It's very messy to deal with the case when the |peer| received&#10;                 TimeoutNowRequest and increase the term while somehow another leader&#10;                 which was not replicated with the newest configuration has been&#10;                 elected. If no add_peer with this very |peer| is to be invoked ever&#10;                 after nor this peer is to be killed, this peer will spin in the voting&#10;                 procedure and make the each new leader stepped down when the peer&#10;                 reached vote timeout and it starts to vote (because it will increase&#10;                 the term of the group)&#10;                 To make things simple, refuse the operation and force users to&#10;                 invoke transfer_leadership_to after configuration changing is&#10;                 completed so that the peer's configuration is up-to-date when it&#10;                 receives the TimeOutNowRequest." />
      <item value="Set the maximum amount of direct memory.  This value is controlled&#10;         by the vm option -XX:MaxDirectMemorySize=&lt;size&gt;.&#10;         The maximum amount of allocatable direct buffer memory (in bytes)&#10;         from the system property sun.nio.MaxDirectMemorySize set by the VM.&#10;         The system property will be removed." />
      <item value="&#10;     Save a private copy of the system properties and remove&#10;     the system properties that are not intended for public access.&#10;    &#10;     This method can only be invoked during system initialization." />
      <item value="save And Remove Properties" />
      <item value="     A user-settable upper limit on the maximum amount of allocatable direct&#10;     buffer memory.  This value may be changed during VM initialization if&#10;     &quot;java&quot; is launched with &quot;-XX:MaxDirectMemorySize=&lt;size&gt;&quot;.&#10;    &#10;     The initial value of this field is arbitrary; during JRE initialization&#10;     it will be reset to the value specified on the command line, if any,&#10;     otherwise to Runtime.getRuntime().maxMemory()." />
      <item value="Buffer Underflow Exception" />
      <item value="Conceptually" />
      <item value="the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often." />
      <item value="     Dummy reference queue, needed because the PhantomReference constructor&#10;     insists that we pass a queue.  Nothing will ever be placed on this queue&#10;     since the reference handler invokes cleaners explicitly." />
      <item value="trivial" />
      <item value="Nontrivial" />
      <item value="A cleaner tracks a referent object and encapsulates a thunk of arbitrary&#10;  cleanup code. " />
      <item value="a thunk of" />
      <item value="thunk" />
      <item value="robust" />
      <item value="Cleaners are a lightweight and more robust alternative to finalization." />
      <item value="General-purpose phantom-reference-based cleaners." />
      <item value="A given arbitrary object may also be attached to the buffer." />
      <item value="allocation Granularity" />
      <item value="For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory." />
      <item value=" One of the constants READ_ONLY, READ_WRITE, or PRIVATE defined in the FileChannel.MapMode class, according to whether the file is to be mapped read-only, readwrite, or privately (copy-on-write), respectively, or an implementation specific map mode" />
      <item value="he behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified." />
      <item value="Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. " />
      <item value="A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping." />
      <item value="The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected." />
      <item value=" The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected." />
      <item value="Changes made to the resulting buffer will not be propagated to the file and will not be visible to other programs that have mapped the same file; instead, they will cause private copies of the modified portions of the buffer to be created. (MapMode.PRIVATE)" />
      <item value="Maps a region of this channel's file directly into memory." />
      <item value="propagate" />
      <item value="COMPLIANCE" />
      <item value="GOVERNANCE" />
      <item value="Retention" />
      <item value="bypass Governance Mode" />
      <item value="&#10;The first byte read is stored into element b[0], the next one into b[1], and so on. The number of bytes read is, at most, equal to the length of b. Let k be the number of bytes actually read; these bytes will be stored in elements b[0] through b[k-1], leaving elements b[k] through b[b.length-1] unaffected." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="520" />
        <entry key="ENGLISH" value="521" />
        <entry key="DANISH" value="1" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1664204311345" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value=".SFNS-Regular" />
    <option name="primaryFontFamily" value=".SFNS-Regular" />
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1672020480587" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="This method is not meaningful with the auth2 interfaces. Authentication would already have happened by headermiddleware with the auth2 classes." />
      <item value="Since both FnMut and FnOnce are supertraits of Fn, any instance of Fn can be used as a parameter where a FnMut or FnOnce is expected." />
      <item value="This trait (Fn) is not to be confused with function pointers (fn)." />
      <item value="Hydrates" />
      <item value="Dehydrates a rich java object into a Parquet row." />
      <item value="Dehydrator" />
      <item value="if either the libname argument contains a file path, the native library is not statically linked with the VM, or the library cannot be mapped to a native library image by the host system." />
      <item value="If a native library called libname is statically linked with the VM, then the JNI_OnLoad_libname function exported by the library is invoked. See the JNI Specification for more details. Otherwise, the libname argument is loaded from a system library location and mapped to a native library image in an implementation- dependent manner." />
      <item value="Hyper List" />
      <item value="Ledger" />
      <item value="Put an asynchronous boundary around this Flow. If this is a SubFlow (created e.g. by groupBy), this creates an asynchronous boundary around each materialized sub-flow, not the super-flow. That way, the super-flow will communicate with sub-flows asynchronously." />
      <item value="Concatenates this Flow with the given Source so the first element emitted by that source is emitted after the last element of this flow." />
      <item value="Connect this Flow to a Sink, concatenating the processing steps of both." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="9" />
        <entry key="ENGLISH" value="10" />
      </map>
    </option>
  </component>
</application>