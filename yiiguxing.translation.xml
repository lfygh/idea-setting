<application>
  <component name="AppStorage">
    <histories>
      <item value="drain" />
      <item value="Delayed" />
      <item value="&#10;Guava implementations of ListenableFuture promptly release references to listeners after executing them" />
      <item value="Memory consistency effects: Actions in a thread prior to adding a listener happen-before its execution begins, perhaps in another thread." />
      <item value="This is the most general listener interface. For common operations performed using listeners, see Futures. For a simplified but general listener interface, see addCallback()." />
      <item value="Note: If your listener is lightweight -- and will not cause stack overflow by completing more futures or adding more directExecutor() listeners inline -- consider MoreExecutors.directExecutor. Otherwise, avoid it: See the warnings on the docs for directExecutor." />
      <item value="There is no guaranteed ordering of execution of listeners, but any listener added through this method is guaranteed to be called once the computation is complete." />
      <item value="There is a race between cancel and the completionfailure of the RPC in other ways. If cancel won the race, Listener.onClose() is called with CANCELLED. Otherwise, Listener.onClose() is called with whatever status the RPC was finished. We ensure that at most one is called." />
      <item value="There is no interaction between the states on the Listener and ClientCall, i.e., if Listener.onClose() is called, it has no bearing on the permitted operations on ClientCall (but it may impact whether they do anything)." />
      <item value="No generic method for determining message receipt or providing acknowledgement is provided. Applications are expected to utilize normal payload messages for such signals, as a response naturally acknowledges its request." />
      <item value="More advanced usages may consume this interface directly as opposed to using a stub. " />
      <item value="If true, indicates that the observer is capable of sending additional messages without requiring excessive buffering internally. This value is just a suggestion and the application is free to ignore it, however doing so may result in excessive buffering within the observer." />
      <item value="This is implemented by the client application and passed into a service method on a stub object." />
      <item value="In any call there are logically four StreamObserver implementations:" />
      <item value="A refinement of StreamObserver provided by the GRPC runtime to the application (the client or the server) that allows for more complex interactions with call behavior." />
      <item value="refinement " />
      <item value="refinement" />
      <item value="A refinement of StreamObserver provided by the GRPC runtime to the application (the client or the server) that allows for more complex interactions with call behavior.&#10;" />
      <item value="gRPC guarantees it does not block on IO in its implementation, but applications are allowed to perform blocking operations in their implementations. However, doing so will delay other callbacks because the methods cannot be called concurrently." />
      <item value="This API is asynchronous, so methods may return before the operation completes. The API provides no guarantees for how quickly an operation will complete, so utilizing flow control via ClientCallStreamObserver and ServerCallStreamObserver to avoid excessive buffering is recommended for streaming RPCs. gRPC's implementation of onError() on client-side causes the RPC to be cancelled and discards all messages, so completes quickly." />
      <item value="Observer" />
      <item value="Shim" />
      <item value="foregoing" />
      <item value="inconsistent" />
      <item value="imposes" />
      <item value="configures the maximum number of substreams (keys) that are supported; if more distinct keys are encountered then the stream fails" />
      <item value="Checks and updates status for a node that failed to acquire. Returns true if thread should block. This is the main signal control in all acquire loops. Requires that pred == node.prev." />
      <item value="Acquires in exclusive uninterruptible mode for thread already in queue. Used by condition wait methods as well as acquire." />
      <item value="detached" />
      <item value="the acquire argument. This value is conveyed to tryAcquire but is otherwise uninterpreted and can represent anything you like." />
      <item value="Acquires in exclusive mode, ignoring interrupts. Implemented by invoking at least once tryAcquire, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success. This method can be used to implement method Lock.lock." />
      <item value="The current owner of exclusive mode synchronization." />
      <item value="Retrieve a single stream associated with a particular descriptor&#10;       associated with the referenced ticket. A Flight can be composed of one or&#10;       more streams where each stream can be retrieved using a separate opaque&#10;       ticket that the flight service uses for managing a collection of streams." />
      <item value="Flight services can support an arbitrary number of simple actions in&#10;       addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut&#10;       operations that are potentially available. DoAction allows a flight client&#10;       to do a specific action against a flight service. An action includes&#10;       opaque request and response objects that are specific to the type action&#10;       being undertaken." />
      <item value="POJO representation of a RecordBatch IPC message (https:arrow.apache.orgdocsformatIPC.html)." />
      <item value="RPC-layer hints for this call." />
      <item value="The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object." />
      <item value="Note that only the locks on this object are relinquished; any other objects on which the current thread may be synchronized remain locked while the thread waits." />
      <item value="relinquish" />
      <item value="This method causes the current thread (referred to here as T) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object." />
      <item value="The current thread must own this object's monitor lock. See the notify method for a description of the ways in which a thread can become the owner of a monitor lock." />
      <item value="The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object." />
      <item value="The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object." />
      <item value="Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation." />
      <item value="If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException." />
      <item value="Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception." />
      <item value="Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. " />
      <item value="Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.&#10;If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.&#10;If this thread is blocked in an IO operation upon an InterruptibleChannel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.&#10;If this thread is blocked in a java.nio.channels.Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked." />
      <item value="Interrupting a thread that is not alive need not have any effect." />
      <item value="If none of the previous conditions hold then this thread's interrupt status will be set." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="174" />
        <entry key="ENGLISH" value="175" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1657014092699" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>