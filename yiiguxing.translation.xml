<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="branch free" />
      <item value="         Add the timeout to the timeout queue which will be processed on the next tick.&#10;         During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket." />
      <item value="Returns the current value of the running Java Virtual Machine's high-resolution time source" />
      <item value="We use 0 as an indicator for the uninitialized value here, so make sure it's not 0 when initialized." />
      <item value="             transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just&#10;             adds new timeouts in a loop." />
      <item value="VIRGIN" />
      <item value="obsolete" />
      <item value="Implementation note: This class scales to large numbers of concurrently scheduled tasks (thousands should present no problem). Internally, it uses a binary heap to represent its task queue, so the cost to schedule a task is O(log n), where n is the number of concurrently scheduled tasks." />
      <item value="&#10;Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the TimerTimerTask combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer." />
      <item value="However, this can take arbitrarily long to occur. By default, the task execution thread does not run as a daemon thread, so it is capable of keeping an application from terminating. If a caller wants to terminate a timer's task execution thread rapidly, the caller should invoke the timer's cancel method." />
      <item value="&#10;After the last live reference to a Timer object goes away and all outstanding tasks have completed execution, the timer's task execution thread terminates gracefully (and becomes subject to garbage collection). " />
      <item value="it &quot;hogs&quot; the timer's task execution thread. This can, in turn, delay the execution of subsequent tasks, which may &quot;bunch up&quot; and execute in rapid succession when (and if) the offending task finally completes." />
      <item value="Corresponding to each Timer object is a single background thread that is used to execute all of the timer's tasks," />
      <item value="Alt Result" />
      <item value="To better conform with the use of common functional forms" />
      <item value="the use of common functional forms," />
      <item value="                 The peer contains logs from old term which should be truncated,&#10;                 decrease _last_log_at_peer by one to test the right index to keep" />
      <item value="   The accuracy is 100, don't ask more" />
      <item value="damn" />
      <item value="This is a sad code, the performance is too damn bad" />
      <item value="the minimum number of keys required to split, less than this value will refuse to split" />
      <item value="return the greatest key less than or equal to the given key" />
      <item value="PlacementDriverServer is a role responsible for overall global control." />
      <item value="A capability-based lock with three modes for controlling readwrite access" />
      <item value="strip" />
      <item value="strip Attrs" />
      <item value="mutated" />
      <item value="         Since there were pendingCalls, we need to process them. To maintain ordering we can't set&#10;         passThrough=true until we run all pendingCalls, but new Runnables may be added after we&#10;         drop the lock. So we will have to re-check pendingCalls." />
      <item value="If realStream != null, then either setStream() or cancel() has been called." />
      <item value=" No need to synchronize; start() synchronization provides a happens-before" />
      <item value="       The channel state does not get updated when doing name resolving today, so for the moment&#10;       let LB report CONNECTION and call subchannel.requestConnection() immediately." />
      <item value="         It's safe to use RequestConnectionPicker here, so when coming from IDLE we could leave&#10;         the current picker in-place. But ignoring the potential optimization is simpler." />
      <item value="Failing" />
      <item value="Failing to do so may result in unnecessary delays of RPCs." />
      <item value="You won't get a notification for the initial IDLE state" />
      <item value="overlap" />
      <item value="If there isn't an active transport yet, and an RPC is assigned to the Subchannel, it will create a new transport. It won't actively create transports otherwise. requestConnection() can be used to ask Subchannel to create a transport if there isn't any." />
      <item value="It maintains at most one physical connection (aka transport) for sending new RPCs, while also keeps track of previous transports that has been shut down but not terminated yet." />
      <item value="Set a new state with a new picker to the channel." />
      <item value="Out-of-band" />
      <item value="whenever" />
      <item value="Always create a new picker and call Helper.updateBalancingState() whenever handleSubchannelState() is called, unless the new state is SHUTDOWN. See handleSubchannelState's javadoc for more details." />
      <item value="The picker should only pick Subchannels that are known as READY or IDLE. Whether to pick IDLE Subchannels depends on whether you want Subchannels to connect on-demand or actively" />
      <item value="respectively" />
      <item value="the rules of thumb" />
      <item value="the rules of thumb are" />
      <item value="thumb" />
      <item value="&#10;This can also happen if you don't create a new picker at key state changes of Subchannels. Take the above round-robin example again. Suppose you do pick only READY and IDLE Subchannels, and initially both Subchannels are READY. Now one becomes IDLE, then CONNECTING and stays CONNECTING for a long time. If you don't create a new picker in response to the CONNECTING state to exclude that Subchannel, 50% of RPCs will hit it and be buffered even though the other Subchannel is READY." />
      <item value="This can happen if you return Subchannels with states other than READY and IDLE. For example, suppose you round-robin on 2 Subchannels, in READY and CONNECTING states respectively. If the picker ignores the state and pick them equally, 50% of RPCs will be stuck in buffered state until both Subchannels are READY." />
      <item value="You will want to avoid running into a situation where there are READY Subchannels out there but some RPCs are still buffered for longer than a brief time." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="484" />
        <entry key="ENGLISH" value="485" />
        <entry key="DANISH" value="1" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1662969784323" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>