<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Runtime only dependencies for source set 'main'" />
      <item value="Iterator over a batch of committed tasks." />
      <item value="     The raft log used fsync by default, and the correctness of&#10;     state-machine data with rheakv depends on the raft log + snapshot,&#10;     so we do not need to fsync." />
      <item value="If the key definitely does not exist in the database, then this method returns false" />
      <item value="That is to say that this method is probabilistic and may return false positives, but never a false negative." />
      <item value="Schedules the specified TimerTask for one-time execution after the specified delay" />
      <item value="The main balancing logic. It must be thread-safe. Typically it should only synchronize on its own state, and avoid synchronizing with the LoadBalancer's state." />
      <item value="&#10;       The channel state does not get updated when doing name resolving today, so for the moment&#10;       let LB report CONNECTION and call subchannel.requestConnection() immediately." />
      <item value="Given the name of a host, returns an array of its IP addresses, based on the configured name service on the system.&#10;The host name can either be a machine name, such as &quot;www.example.com&quot;, or a textual representation of its IP address. If a literal IP address is supplied, only the validity of the address format is checked.&#10;" />
      <item value="An implementation must generate it without blocking, typically in line, and must keep it unchanged. NameResolvers created from the same factory with the same argument must return the same authority." />
      <item value="Returns the authority used to authenticate connections to servers. It must be from a trusted source, because if the authority is tampered with, RPCs may be sent to the attackers which may leak sensitive user data." />
      <item value="Returns the authority used to authenticate connections to servers" />
      <item value="Implementations don't need to be thread-safe. All methods are guaranteed to be called sequentially. Additionally, all methods that have side-effects, i.e., start(NameResolver.Listener2), shutdown and refresh are called from the same SynchronizationContext as returned by NameResolver.Args.getSynchronizationContext. Do not block within the synchronization context; blocking IO and time-consuming tasks should be offloaded to a separate thread, generally NameResolver.Args.getOffloadExecutor." />
      <item value="A NameResolver does not need to automatically re-resolve on failure. Instead, the NameResolver.Listener is responsible for eventually (after an appropriate backoff period) invoking refresh()." />
      <item value="A NameResolver uses the URI's scheme to determine whether it can resolve it, and uses the components after the scheme for actual resolution." />
      <item value="The channel state does not get updated when doing name resolving today, so for the moment&#10;       let LB report CONNECTION and call subchannel.requestConnection() immediately." />
      <item value="Conceptually, it is fairly accurate to think of SynchronizationContext like a cheaper Executors.newSingleThreadExecutor() when used for synchronization (not long-running tasks). Both use a queue for tasks that are run in order and neither guarantee that tasks have completed before returning from execute(). However, the behavior does diverge if locks are held when calling the context. So it is encouraged to avoid mixing locks and synchronization context except via executeLater.&#10;" />
      <item value=").&#10;Implementations don't need to be thread-safe. All methods are guaranteed to be called sequentially. Additionally, all methods that have side-effects, i.e., start(NameResolver.Listener2), shutdown and refresh are called from the same SynchronizationContext as returned by NameResolver.Args.getSynchronizationContext. Do not block within the synchronization context; blocking IO and time-consuming tasks should be offloaded to a separate thread, generally NameResolver.Args.getOffloadExecutor." />
      <item value="  exitIdleMode() may be called outside of inUseStateAggregator.handleNotInUse() while&#10;       isInUse() == false, in which case we still need to schedule the timer." />
      <item value="It doesn't own any thread. Tasks are run from caller's or caller-provided threads.&#10;Conceptually, it is fairly accurate to think of SynchronizationContext like a cheaper Executors.newSingleThreadExecutor() when used for synchronization (not long-running tasks). Both use a queue for tasks that are run in order and neither guarantee that tasks have completed before returning from execute(). However, the behavior does diverge if locks are held when calling the context. So it is encouraged to avoid mixing locks and synchronization context except via executeLater." />
      <item value="Non-reentrancy. If a task running in a synchronization context executes or schedules another task in the same synchronization context, the latter task will never run inline. It will instead be queued and run only after the current task has returned." />
      <item value="Ordering. Tasks are run in the same order as they are submitted via execute and executeLater.&#10;Serialization. Tasks are run in sequence and establish a happens-before relationship between them." />
      <item value="&#10;Providing authentication credentials is better served by CallCredentials. But a ClientInterceptor could set the CallCredentials within the CallOptions." />
      <item value="Interface for intercepting outgoing calls before they are dispatched by a Channel." />
      <item value="Spying" />
      <item value="&#10;A NameResolver does not need to automatically re-resolve on failure. Instead, the NameResolver.Listener is responsible for eventually (after an appropriate backoff period) invoking refresh()." />
      <item value="hedging" />
      <item value="update configuration after _log_manager updated its memory status" />
      <item value="                     The change of term indicates that leader has been changed during&#10;                     appending entries, so we can't respond ok to the old leader&#10;                     because we are not sure if the appended logs would be truncated&#10;                     by the new leader:&#10;                      - If they won't be truncated and we respond failure to the old&#10;                        leader, the new leader would know that they are stored in this&#10;                        peer and they will be eventually committed when the new leader&#10;                        found that quorum of the cluster have stored.&#10;                      - If they will be truncated and we responded success to the old&#10;                        leader, the old leader would possibly regard those entries as&#10;                        committed (very likely in a 3-nodes cluster) and respond&#10;                        success to the clients, which would break the rule that&#10;                        committed entries would never be truncated.&#10;                     So we have to respond failure to the old leader and set the new&#10;                     term to make it stepped down if it didn't." />
      <item value="&#10;                 The log at prev_log_index has been compacted, which indicates&#10;                 we is or is going to install snapshot to the follower. So we let&#10;                 both prev_log_index and prev_log_term be 0 in the heartbeat&#10;                 request so that follower would do nothing besides updating its&#10;                 leader timestamp." />
      <item value="ELEADERCONFLICT" />
      <item value="set task entry info before adding to list" />
      <item value="Reject this task if expectedTerm doesn't match the current term of this Node if the value is not -1, default is -1" />
      <item value="Start follower's replicators" />
      <item value="signal fsm leader stop immediately" />
      <item value="EHIGHERTERMRESPONSE" />
      <item value="noinspection ConstantConditions" />
      <item value="A follower replicator may not be started when this node become leader, so we must check it." />
      <item value=" Node is currently the leader and |entries| are from the user who&#10;             don't know the correct indexes the logs should assign to. So we have&#10;             to assign indexes to the appending entries" />
      <item value="  Appending entries overlap the local ones. We should find if there&#10;                 is a conflicting index from which we should truncate the local&#10;                 ones." />
      <item value=" if have log using conf in log, else using conf in options" />
      <item value="Judge whether to launch a election." />
      <item value="for the performance consideration, we will take away the&#10;                    content. If you want keep the content, copy it before call&#10;                    this function" />
      <item value=" Most configurations do not need to be configured separately for each raft-group," />
      <item value="Lists incomplete object upload information of a bucket." />
      <item value="Sets default object retention in a bucket." />
      <item value="Gets presigned URL of an object for HTTP method, expiry time and custom request parameters." />
      <item value="Presigned" />
      <item value="Creates an object by combining data from different source objects using server-side copy." />
      <item value="Reads up to len bytes of data" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="376" />
        <entry key="ENGLISH" value="377" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1661095693892" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>