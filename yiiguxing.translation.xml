<application>
  <component name="AppStorage">
    <histories>
      <item value="This worker timed out waiting for a task, and timed-out workers are subject to termination" />
      <item value="the task the new thread should run first (or null if none). Workers are created with an initial first task (in method execute()) to bypass queuing when there are fewer than corePoolSize threads (in which case we always start one), or when the queue is full (in which case we must bypass queue). Initially idle threads are usually created via prestartCoreThread or to replace other dying workers." />
      <item value="eligible to shut down" />
      <item value="eligible" />
      <item value="accordingly" />
      <item value="If so, the worker count is adjusted accordingly," />
      <item value="with respect to" />
      <item value="Checks if a new worker can be added with respect to current pool state and the given bound (either core or maximum)." />
      <item value="inhibit interrupts until runWorker" />
      <item value=" This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run" />
      <item value="opportunistically" />
      <item value="This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock surrounding each task execution." />
      <item value="bookkeeping" />
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping. " />
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping. T" />
      <item value="along with other minor bookkeeping." />
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks" />
      <item value="The queue used for holding tasks and handing off to worker threads. We do not require that workQueue.poll() returning null necessarily means that workQueue.isEmpty(), so rely solely on isEmpty to see if the queue is empty (which we must do for example when deciding whether to transition from SHUTDOWN to TIDYING). This accommodates special-purpose queues such as DelayQueues for which poll() is allowed to return null even if it may later return non-null when delays expire." />
      <item value="The queue used for holding tasks and handing off to worker threads. We do not require that workQueue.poll() returning null necessarily means that workQueue.isEmpty()," />
      <item value="relinquishes" />
      <item value="Sets head of queue, and checks if successor may be waiting in shared mode, if so propagating if either propagate &gt; 0 or PROPAGATE status was set." />
      <item value=" Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquireShared until success" />
      <item value="Acquires in shared mode, ignoring interrupts. Implemented by first invoking at least once tryAcquireShared, returning on success." />
      <item value="As a heuristic to avoid indefinite writer starvation" />
      <item value="barge" />
      <item value="Attempts to set the state to reflect a release in shared mode." />
      <item value="true if this release of shared mode may permit a waiting acquire (shared or exclusive) to succeed; and false otherwise" />
      <item value=" Decrement count; signal when transition to zero" />
      <item value="lies dormant " />
      <item value="dormant" />
      <item value="A useful property of a CountDownLatch is that it doesn't require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass." />
      <item value="versatile" />
      <item value=" This is a one-shot phenomenon -- the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier" />
      <item value="A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown method" />
      <item value="A template trait for collections which can be traversed either once only or one or more times.&#10;" />
      <item value="precisely" />
      <item value="Accessed via a benign data race; relies on the memory model's out-of-thin-air guarantees for references.&#10;This allows tracking of read holds for uncontended read locks to be very cheap." />
      <item value="relinquishing" />
      <item value="Cannot cause garbage retention unless the thread terminated without relinquishing its read locks, since tryReleaseShared sets it to null." />
      <item value="&#10;More precisely, firstReader is the unique thread that last changed the shared count from 0 to 1, and has not released the read lock since then; null if there is no such thread." />
      <item value="More precisely" />
      <item value="Acquires only if reentrant or queue is empty." />
      <item value="A synchronizer that may be exclusively owned by a thread. This class provides a basis for creating locks and related synchronizers that may entail a notion of ownership. The AbstractOwnableSynchronizer class itself does not manage or use this information. However, subclasses and tools may use appropriately maintained values to help control and monitor access and provide diagnostics." />
      <item value="true if synchronization is held exclusively;" />
      <item value="Returns true if synchronization is held exclusively with respect to the current (calling) thread. This method is invoked upon each call to a AbstractQueuedSynchronizer.ConditionObject method." />
      <item value="If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens" />
      <item value="Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one." />
      <item value="In addition to" />
      <item value="&#10;In addition to implementing the Lock interface, this class defines a number of public and protected methods for inspecting the state of the lock. Some of these methods are only useful for instrumentation and monitoring." />
      <item value="&#10;The constructor for this class accepts an optional fairness parameter. When set true, under contention, locks favor granting access to the longest-waiting thread." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="248" />
        <entry key="ENGLISH" value="249" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1657497824818" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>