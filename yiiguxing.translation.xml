<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="In order to be used with a selector, an instance of this class must first be registered via the register method. This method returns a new SelectionKey object that represents the channel's registration with the selector." />
      <item value="A channel that can be multiplexed via a Selector." />
      <item value=" It is not possible to create a channel for an arbitrary, pre-existing ServerSocket. " />
      <item value="The class Exception and any subclasses that are not also subclasses of RuntimeException are checked exceptions. " />
      <item value="The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch." />
      <item value="that&#10;          the pool shut down since entry into this method" />
      <item value="          1. If fewer than corePoolSize threads are running, try to&#10;          start a new thread with the given command as its first&#10;          task.  The call to addWorker atomically checks runState and&#10;          workerCount, and so prevents false alarms that would add&#10;          threads when it shouldn't, by returning false." />
      <item value="implies" />
      <item value="&#10;Here is a class with a method that sets up a ScheduledExecutorService to beep every ten seconds for an hour" />
      <item value="the remaining delay; zero or negative values indicate that the delay has already elapsed" />
      <item value="A mix-in style interface for marking objects that should be acted upon after a given delay." />
      <item value="A follower replicator may not be started when this node become leader, so we must check it." />
      <item value="Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution.&#10;" />
      <item value="      5. After task.run completes, we call afterExecute, which may&#10;      also throw an exception, which will also cause thread to&#10;      die. According to JLS Sec 14.20, this exception is the one that&#10;      will be in effect even if task.run throws." />
      <item value="      The net effect of the exception mechanics is that afterExecute&#10;      and the thread's UncaughtExceptionHandler have as accurate&#10;      information as we can provide about any problems encountered by&#10;      user code." />
      <item value="Any thrown exception also&#10;      conservatively causes thread to die." />
      <item value="conservatively" />
      <item value="We separately handle RuntimeException, Error (both of which the&#10;      specs guarantee that we trap) and arbitrary Throwables." />
      <item value="a call to beforeExecute" />
      <item value="Each task run is preceded by a call to beforeExecute," />
      <item value="preceded" />
      <item value="Each task run is preceded by a call to beforeExecute" />
      <item value="Before running any task, the lock is acquired to prevent&#10;      other pool interrupts while the task is executing, and then we&#10;      ensure that unless pool is stopping, this thread does not have&#10;      its interrupt set." />
      <item value="If it returns null then the&#10;      worker exits due to changed pool state or configuration&#10;      parameters." />
      <item value="coping with a number of issues" />
      <item value="while coping with a number of issues" />
      <item value="Main worker run loop.  Repeatedly gets tasks from queue and&#10;      executes them, while coping with a number of issues" />
      <item value="Internal errors. Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken." />
      <item value="interest" />
      <item value="Transitions runState to given target, or leaves it alone if already at least the given target." />
      <item value="inhibit interrupts until runWorker" />
      <item value="Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty). If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate. This method must be called following any action that might make termination possible -- reducing worker count or removing tasks from the queue during shutdown. The method is non-private to allow access from ScheduledThreadPoolExecutor." />
      <item value="Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)." />
      <item value="This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using submit might be converted into a form that maintains Future status. However, in such cases, method purge may be used to remove those Futures that have been cancelled." />
      <item value="Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started.&#10;This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using submit might be converted into a form that maintains Future status. However, in such cases, method purge may be used to remove those Futures that have been cancelled." />
      <item value="Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started." />
      <item value="          2. If a task can be successfully queued, then we still need&#10;          to double-check whether we should have added a thread&#10;          (because existing ones died since last checking) or that&#10;          the pool shut down since entry into this method. So we&#10;          recheck state and if necessary roll back the enqueuing if&#10;          stopped, or start a new thread if there are none." />
      <item value="this method is generally preferable to add," />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception." />
      <item value=" violating" />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. " />
      <item value="&#10;poll" />
      <item value="BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future" />
      <item value="Performs cleanup and bookkeeping for a dying worker. Called only from worker threads. Unless completedAbruptly is set, assumes that workerCount has already been adjusted to account for exit. This method removes thread from worker set, and possibly terminates the pool or replaces the worker if either it exited due to user task exception or if fewer than corePoolSize workers are running or queue is non-empty but there are no workers." />
      <item value="completed Abruptly" />
      <item value="dying" />
      <item value="Performs cleanup and bookkeeping for a dying worker." />
      <item value="If abrupt, then workerCount wasn't adjusted" />
      <item value="Method invoked prior to executing the given Runnable in the given thread. This method is invoked by thread t that will execute task r, and may be used to re-initialize ThreadLocals, or to perform logging.&#10;This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke super.beforeExecute at the end of this method." />
      <item value="A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="309" />
        <entry key="ENGLISH" value="310" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658555400153" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>