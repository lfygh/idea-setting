<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Lists incomplete object upload information of a bucket." />
      <item value="Sets default object retention in a bucket." />
      <item value="Gets presigned URL of an object for HTTP method, expiry time and custom request parameters." />
      <item value="Presigned" />
      <item value="Creates an object by combining data from different source objects using server-side copy." />
      <item value="Reads up to len bytes of data" />
      <item value="Only one write operation upon a writable channel may be in progress at any given time. If one thread initiates a write operation upon a channel then any other thread that attempts to initiate another write operation will block until the first operation is complete. Whether or not other kinds of IO operations may proceed concurrently with a write operation depends upon the type of the channel." />
      <item value="         If a buffer of this size is too large for the cache, there&#10;         should not be a buffer in the cache that is at least as&#10;         large. So we'll just create a new one. Also, we don't have&#10;         to remove the buffer from the cache (as this method does&#10;         below) given that we won't put the new buffer in the cache." />
      <item value="vice versa; " />
      <item value="&#10;This class defines methods for reading and writing values of all other primitive types, except boolean. Primitive values are translated to (or from) sequences of bytes according to the buffer's current byte order, which may be retrieved and modified via the order methods. Specific byte orders are represented by instances of the ByteOrder class. The initial order of a byte buffer is always BIG_ENDIAN." />
      <item value="&#10;Whether a byte buffer is direct or non-direct may be determined by invoking its isDirect method. This method is provided so that explicit buffer management can be done in performance-critical code. " />
      <item value="A direct byte buffer may also be created by mapping a region of a file directly into memory. An implementation of the Java platform may optionally support the creation of direct byte buffers from native code via JNI. If an instance of one of these kinds of buffers refers to an inaccessible region of memory then an attempt to access that region will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time." />
      <item value="A direct byte buffer may be created by invoking the allocateDirect factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system's native IO operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance." />
      <item value="A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native IO operations directly upon it. That is, it will attempt to avoid copying the buffer's content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system's native IO operations." />
      <item value="The first byte read is stored into element b[off], the next one into b[off+1], and so on. The number of bytes read is, at most, equal to len. Let k be the number of bytes actually read; these bytes will be stored in elements b[off] through b[off+k-1], leaving elements b[off+k] through b[off+len-1] unaffected.&#10;In every case, elements b[0] through b[off] and elements b[off+len] through b[b.length-1] are unaffected." />
      <item value="&#10;The first byte read is stored into element b[off], the next one into b[off+1]" />
      <item value="Reads up to len bytes of data from the input stream into an array of bytes. An attempt is made to read as many as len bytes, but a smaller number may be read. The number of bytes actually read is returned as an integer." />
      <item value="Whether or not a channel is registered with one or more selectors may be determined by invoking the isRegistered method." />
      <item value="A channel may be registered at most once with any particular selector." />
      <item value="A channel cannot be deregistered directly; instead, the key representing its registration must be cancelled. Cancelling a key requests that the channel be deregistered during the selector's next selection operation. A key may be cancelled explicitly by invoking its cancel method. All of a channel's keys are cancelled implicitly when the channel is closed, whether by invoking its close method or by interrupting a thread blocked in an IO operation upon the channel." />
      <item value="A channel cannot be deregistered directly; instead, the key representing its registration must be cancelled." />
      <item value="Once registered with a selector, a channel remains registered until it is deregistered. This involves deallocating whatever resources were allocated to the channel by the selector.&#10;" />
      <item value="&#10;In order to be used with a selector, an instance of this class must first be registered via the register method. This method returns a new SelectionKey object that represents the channel's registration with the selector." />
      <item value="In order to be used with a selector, an instance of this class must first be registered via the register method. This method returns a new SelectionKey object that represents the channel's registration with the selector." />
      <item value="A channel that can be multiplexed via a Selector." />
      <item value=" It is not possible to create a channel for an arbitrary, pre-existing ServerSocket. " />
      <item value="The class Exception and any subclasses that are not also subclasses of RuntimeException are checked exceptions. " />
      <item value="The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch." />
      <item value="that&#10;          the pool shut down since entry into this method" />
      <item value="          1. If fewer than corePoolSize threads are running, try to&#10;          start a new thread with the given command as its first&#10;          task.  The call to addWorker atomically checks runState and&#10;          workerCount, and so prevents false alarms that would add&#10;          threads when it shouldn't, by returning false." />
      <item value="implies" />
      <item value="&#10;Here is a class with a method that sets up a ScheduledExecutorService to beep every ten seconds for an hour" />
      <item value="the remaining delay; zero or negative values indicate that the delay has already elapsed" />
      <item value="A mix-in style interface for marking objects that should be acted upon after a given delay." />
      <item value="A follower replicator may not be started when this node become leader, so we must check it." />
      <item value="Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution.&#10;" />
      <item value="      5. After task.run completes, we call afterExecute, which may&#10;      also throw an exception, which will also cause thread to&#10;      die. According to JLS Sec 14.20, this exception is the one that&#10;      will be in effect even if task.run throws." />
      <item value="      The net effect of the exception mechanics is that afterExecute&#10;      and the thread's UncaughtExceptionHandler have as accurate&#10;      information as we can provide about any problems encountered by&#10;      user code." />
      <item value="Any thrown exception also&#10;      conservatively causes thread to die." />
      <item value="conservatively" />
      <item value="We separately handle RuntimeException, Error (both of which the&#10;      specs guarantee that we trap) and arbitrary Throwables." />
      <item value="a call to beforeExecute" />
      <item value="Each task run is preceded by a call to beforeExecute," />
      <item value="preceded" />
      <item value="Each task run is preceded by a call to beforeExecute" />
      <item value="Before running any task, the lock is acquired to prevent&#10;      other pool interrupts while the task is executing, and then we&#10;      ensure that unless pool is stopping, this thread does not have&#10;      its interrupt set." />
      <item value="If it returns null then the&#10;      worker exits due to changed pool state or configuration&#10;      parameters." />
      <item value="coping with a number of issues" />
      <item value="while coping with a number of issues" />
      <item value="Main worker run loop.  Repeatedly gets tasks from queue and&#10;      executes them, while coping with a number of issues" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="331" />
        <entry key="ENGLISH" value="332" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658995552180" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>