<application>
  <component name="AppStorage">
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="                 The peer contains logs from old term which should be truncated,&#10;                 decrease _last_log_at_peer by one to test the right index to keep" />
      <item value="   The accuracy is 100, don't ask more" />
      <item value="damn" />
      <item value="This is a sad code, the performance is too damn bad" />
      <item value="the minimum number of keys required to split, less than this value will refuse to split" />
      <item value="return the greatest key less than or equal to the given key" />
      <item value="PlacementDriverServer is a role responsible for overall global control." />
      <item value="A capability-based lock with three modes for controlling readwrite access" />
      <item value="strip" />
      <item value="strip Attrs" />
      <item value="mutated" />
      <item value="         Since there were pendingCalls, we need to process them. To maintain ordering we can't set&#10;         passThrough=true until we run all pendingCalls, but new Runnables may be added after we&#10;         drop the lock. So we will have to re-check pendingCalls." />
      <item value="If realStream != null, then either setStream() or cancel() has been called." />
      <item value=" No need to synchronize; start() synchronization provides a happens-before" />
      <item value="       The channel state does not get updated when doing name resolving today, so for the moment&#10;       let LB report CONNECTION and call subchannel.requestConnection() immediately." />
      <item value="         It's safe to use RequestConnectionPicker here, so when coming from IDLE we could leave&#10;         the current picker in-place. But ignoring the potential optimization is simpler." />
      <item value="Failing" />
      <item value="Failing to do so may result in unnecessary delays of RPCs." />
      <item value="You won't get a notification for the initial IDLE state" />
      <item value="overlap" />
      <item value="If there isn't an active transport yet, and an RPC is assigned to the Subchannel, it will create a new transport. It won't actively create transports otherwise. requestConnection() can be used to ask Subchannel to create a transport if there isn't any." />
      <item value="It maintains at most one physical connection (aka transport) for sending new RPCs, while also keeps track of previous transports that has been shut down but not terminated yet." />
      <item value="Set a new state with a new picker to the channel." />
      <item value="Out-of-band" />
      <item value="whenever" />
      <item value="Always create a new picker and call Helper.updateBalancingState() whenever handleSubchannelState() is called, unless the new state is SHUTDOWN. See handleSubchannelState's javadoc for more details." />
      <item value="The picker should only pick Subchannels that are known as READY or IDLE. Whether to pick IDLE Subchannels depends on whether you want Subchannels to connect on-demand or actively" />
      <item value="respectively" />
      <item value="the rules of thumb" />
      <item value="the rules of thumb are" />
      <item value="thumb" />
      <item value="&#10;This can also happen if you don't create a new picker at key state changes of Subchannels. Take the above round-robin example again. Suppose you do pick only READY and IDLE Subchannels, and initially both Subchannels are READY. Now one becomes IDLE, then CONNECTING and stays CONNECTING for a long time. If you don't create a new picker in response to the CONNECTING state to exclude that Subchannel, 50% of RPCs will hit it and be buffered even though the other Subchannel is READY." />
      <item value="This can happen if you return Subchannels with states other than READY and IDLE. For example, suppose you round-robin on 2 Subchannels, in READY and CONNECTING states respectively. If the picker ignores the state and pick them equally, 50% of RPCs will be stuck in buffered state until both Subchannels are READY." />
      <item value="You will want to avoid running into a situation where there are READY Subchannels out there but some RPCs are still buffered for longer than a brief time." />
      <item value="&#10;Note that Subchannel's state may change at the same time the picker is making the decision, which means the decision may be made with (to-be) outdated information. For example, a picker may return a Subchannel known to be READY, but it has become IDLE when is about to be used by the RPC, which makes the RPC to be buffered. The LoadBalancer will soon learn about the Subchannels' transition from READY to IDLE, create a new picker and allow the RPC to use another READY transport if there is any." />
      <item value="Note that Subchannel's state may change at the same time the picker is making the decision, which means the decision may be made with (to-be) outdated information. " />
      <item value="When the RPC tries to use the return Subchannel, which is briefly after this method returns, the state of the Subchannel will decide where the RPC would go:" />
      <item value="The Subchannel should either be an original Subchannel returned by Helper.createSubchannel(), or a wrapper of it preferably based on ForwardingSubchannel. At the very least its getInternalSubchannel() must return the same object as the one returned by the original. Otherwise the Channel cannot use it for the RPC.&#10;" />
      <item value="proceed" />
      <item value="A decision to proceed the RPC on a Subchannel." />
      <item value="     An error to be propagated to the application if subchannel == null&#10;     Or OK if there is no error.&#10;     subchannel being null and error being OK means RPC needs to wait" />
      <item value="Buffer: in all other cases, the RPC will be buffered in the Channel, until the next picker is provided via Helper.updateBalancingState(), when the RPC will go through the same picking process again." />
      <item value="Proceed: if a Subchannel is provided via withSubchannel(), and is in READY state when the RPC tries to start on it, the RPC will proceed on that Subchannel." />
      <item value="If the new state is not SHUTDOWN, this method should create a new picker and call Helper.updateBalancingState(). Failing to do so may result in unnecessary delays of RPCs. Please refer to PickResult.withSubchannel()'s javadoc for more information." />
      <item value="No synchronization should be necessary between LoadBalancer and its pickers if you follow the pattern above. It may be possible to implement in a different way, but that would usually result in more complicated threading." />
      <item value="A typical SubchannelPicker holds a snapshot of these states. It may have its own states, e.g., a picker from a round-robin load-balancer may keep a pointer to the next Subchannel, which are typically mutated by multiple threads. The picker should only mutate its own state, and should not mutate or re-acquire the states of the LoadBalancer. This way the picker only needs to synchronize its own states, which is typically trivial to implement." />
      <item value="&#10;A LoadBalancer keeps states like the latest addresses from NameResolver, the Subchannel(s) and their latest connectivity states. These states are mutated within the Synchronization Context," />
      <item value="The canonical implementation pattern" />
      <item value="Examples or work that must be avoided: CPU-intensive calculation, waiting on synchronization primitives, blocking IO, blocking RPCs, etc." />
      <item value="Helper is implemented by gRPC library and provided to Factory. It provides functionalities that a LoadBalancer implementation would typically need." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="469" />
        <entry key="ENGLISH" value="470" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1662531421212" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
</application>